{"ast":null,"code":"import { __read } from \"tslib\";\nimport { eventToSentryRequest, getEnvelopeEndpointWithUrlEncodedAuth, getStoreEndpointWithUrlEncodedAuth, initAPIDetails, sessionToSentryRequest } from '@sentry/core';\nimport { createClientReportEnvelope, disabledUntil, dsnToString, eventStatusFromHttpCode, getGlobalObject, isRateLimited, logger, makePromiseBuffer, serializeEnvelope, updateRateLimits } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { sendReport } from './utils';\nfunction requestTypeToCategory(ty) {\n  var tyStr = ty;\n  return tyStr === 'event' ? 'error' : tyStr;\n}\nvar global = getGlobalObject();\n/** Base Transport class implementation */\nvar BaseTransport = /** @class */function () {\n  function BaseTransport(options) {\n    var _this = this;\n    this.options = options;\n    /** A simple buffer holding all requests. */\n    this._buffer = makePromiseBuffer(30);\n    /** Locks transport after receiving rate limits in a response */\n    this._rateLimits = {};\n    this._outcomes = {};\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', function () {\n        if (global.document.visibilityState === 'hidden') {\n          _this._flushOutcomes();\n        }\n      });\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendEvent = function (event) {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendSession = function (session) {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.recordLostEvent = function (reason, category) {\n    var _a;\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n    var key = requestTypeToCategory(category) + \":\" + reason;\n    IS_DEBUG_BUILD && logger.log(\"Adding outcome: \" + key);\n    this._outcomes[key] = (_a = this._outcomes[key], _a !== null && _a !== void 0 ? _a : 0) + 1;\n  };\n  /**\n   * Send outcomes as an envelope\n   */\n  BaseTransport.prototype._flushOutcomes = function () {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    var outcomes = this._outcomes;\n    this._outcomes = {};\n    // Nothing to send\n    if (!Object.keys(outcomes).length) {\n      IS_DEBUG_BUILD && logger.log('No outcomes to flush');\n      return;\n    }\n    IS_DEBUG_BUILD && logger.log(\"Flushing outcomes:\\n\" + JSON.stringify(outcomes, null, 2));\n    var url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);\n    var discardedEvents = Object.keys(outcomes).map(function (key) {\n      var _a = __read(key.split(':'), 2),\n        category = _a[0],\n        reason = _a[1];\n      return {\n        reason: reason,\n        category: category,\n        quantity: outcomes[key]\n      };\n      // TODO: Improve types on discarded_events to get rid of cast\n    });\n    var envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      IS_DEBUG_BUILD && logger.error(e);\n    }\n  };\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  BaseTransport.prototype._handleResponse = function (_a) {\n    var requestType = _a.requestType,\n      response = _a.response,\n      headers = _a.headers,\n      resolve = _a.resolve,\n      reject = _a.reject;\n    var status = eventStatusFromHttpCode(response.status);\n    this._rateLimits = updateRateLimits(this._rateLimits, headers);\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._isRateLimited(requestType)) {\n      IS_DEBUG_BUILD &&\n      // eslint-disable-next-line deprecation/deprecation\n      logger.warn(\"Too many \" + requestType + \" requests, backing off until: \" + this._disabledUntil(requestType));\n    }\n    if (status === 'success') {\n      resolve({\n        status: status\n      });\n      return;\n    }\n    reject(response);\n  };\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   *\n   * @deprecated Please use `disabledUntil` from @sentry/utils\n   */\n  BaseTransport.prototype._disabledUntil = function (requestType) {\n    var category = requestTypeToCategory(requestType);\n    return new Date(disabledUntil(this._rateLimits, category));\n  };\n  /**\n   * Checks if a category is rate limited\n   *\n   * @deprecated Please use `isRateLimited` from @sentry/utils\n   */\n  BaseTransport.prototype._isRateLimited = function (requestType) {\n    var category = requestTypeToCategory(requestType);\n    return isRateLimited(this._rateLimits, category);\n  };\n  return BaseTransport;\n}();\nexport { BaseTransport };","map":{"version":3,"names":["eventToSentryRequest","getEnvelopeEndpointWithUrlEncodedAuth","getStoreEndpointWithUrlEncodedAuth","initAPIDetails","sessionToSentryRequest","createClientReportEnvelope","disabledUntil","dsnToString","eventStatusFromHttpCode","getGlobalObject","isRateLimited","logger","makePromiseBuffer","serializeEnvelope","updateRateLimits","IS_DEBUG_BUILD","sendReport","requestTypeToCategory","ty","tyStr","global","BaseTransport","options","_this","_buffer","_rateLimits","_outcomes","_api","dsn","_metadata","tunnel","url","sendClientReports","document","addEventListener","visibilityState","_flushOutcomes","prototype","sendEvent","event","_sendRequest","sendSession","session","close","timeout","drain","recordLostEvent","reason","category","key","log","_a","outcomes","Object","keys","length","JSON","stringify","discardedEvents","map","__read","split","quantity","envelope","e","error","_handleResponse","requestType","response","headers","resolve","reject","status","_isRateLimited","warn","_disabledUntil","Date"],"sources":["../../../../src/transports/base.ts"],"sourcesContent":["import {\n  APIDetails,\n  eventToSentryRequest,\n  getEnvelopeEndpointWithUrlEncodedAuth,\n  getStoreEndpointWithUrlEncodedAuth,\n  initAPIDetails,\n  sessionToSentryRequest,\n} from '@sentry/core';\nimport {\n  ClientReport,\n  Event,\n  Outcome,\n  Response as SentryResponse,\n  SentryRequest,\n  SentryRequestType,\n  Session,\n  Transport,\n  TransportOptions,\n} from '@sentry/types';\nimport {\n  createClientReportEnvelope,\n  disabledUntil,\n  dsnToString,\n  eventStatusFromHttpCode,\n  getGlobalObject,\n  isRateLimited,\n  logger,\n  makePromiseBuffer,\n  PromiseBuffer,\n  RateLimits,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../flags';\nimport { sendReport } from './utils';\n\nfunction requestTypeToCategory(ty: SentryRequestType): string {\n  const tyStr = ty as string;\n  return tyStr === 'event' ? 'error' : tyStr;\n}\n\nconst global = getGlobalObject<Window>();\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /**\n   * @deprecated\n   */\n  public url: string;\n\n  /** Helper to get Sentry API endpoints. */\n  protected readonly _api: APIDetails;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<SentryResponse> = makePromiseBuffer(30);\n\n  /** Locks transport after receiving rate limits in a response */\n  protected _rateLimits: RateLimits = {};\n\n  protected _outcomes: { [key: string]: number } = {};\n\n  public constructor(public options: TransportOptions) {\n    this._api = initAPIDetails(options.dsn, options._metadata, options.tunnel);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = getStoreEndpointWithUrlEncodedAuth(this._api.dsn);\n\n    if (this.options.sendClientReports && global.document) {\n      global.document.addEventListener('visibilitychange', () => {\n        if (global.document.visibilityState === 'hidden') {\n          this._flushOutcomes();\n        }\n      });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): PromiseLike<SentryResponse> {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session): PromiseLike<SentryResponse> {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public recordLostEvent(reason: Outcome, category: SentryRequestType): void {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n    // We want to track each category (event, transaction, session) separately\n    // but still keep the distinction between different type of outcomes.\n    // We could use nested maps, but it's much easier to read and type this way.\n    // A correct type for map-based implementation if we want to go that route\n    // would be `Partial<Record<SentryRequestType, Partial<Record<Outcome, number>>>>`\n    const key = `${requestTypeToCategory(category)}:${reason}`;\n    IS_DEBUG_BUILD && logger.log(`Adding outcome: ${key}`);\n    this._outcomes[key] = (this._outcomes[key] ?? 0) + 1;\n  }\n\n  /**\n   * Send outcomes as an envelope\n   */\n  protected _flushOutcomes(): void {\n    if (!this.options.sendClientReports) {\n      return;\n    }\n\n    const outcomes = this._outcomes;\n    this._outcomes = {};\n\n    // Nothing to send\n    if (!Object.keys(outcomes).length) {\n      IS_DEBUG_BUILD && logger.log('No outcomes to flush');\n      return;\n    }\n\n    IS_DEBUG_BUILD && logger.log(`Flushing outcomes:\\n${JSON.stringify(outcomes, null, 2)}`);\n\n    const url = getEnvelopeEndpointWithUrlEncodedAuth(this._api.dsn, this._api.tunnel);\n\n    const discardedEvents = Object.keys(outcomes).map(key => {\n      const [category, reason] = key.split(':');\n      return {\n        reason,\n        category,\n        quantity: outcomes[key],\n      };\n      // TODO: Improve types on discarded_events to get rid of cast\n    }) as ClientReport['discarded_events'];\n    const envelope = createClientReportEnvelope(discardedEvents, this._api.tunnel && dsnToString(this._api.dsn));\n\n    try {\n      sendReport(url, serializeEnvelope(envelope));\n    } catch (e) {\n      IS_DEBUG_BUILD && logger.error(e);\n    }\n  }\n\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  protected _handleResponse({\n    requestType,\n    response,\n    headers,\n    resolve,\n    reject,\n  }: {\n    requestType: SentryRequestType;\n    response: Response | XMLHttpRequest;\n    headers: Record<string, string | null>;\n    resolve: (value?: SentryResponse | PromiseLike<SentryResponse> | null | undefined) => void;\n    reject: (reason?: unknown) => void;\n  }): void {\n    const status = eventStatusFromHttpCode(response.status);\n\n    this._rateLimits = updateRateLimits(this._rateLimits, headers);\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._isRateLimited(requestType)) {\n      IS_DEBUG_BUILD &&\n        // eslint-disable-next-line deprecation/deprecation\n        logger.warn(`Too many ${requestType} requests, backing off until: ${this._disabledUntil(requestType)}`);\n    }\n\n    if (status === 'success') {\n      resolve({ status });\n      return;\n    }\n\n    reject(response);\n  }\n\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   *\n   * @deprecated Please use `disabledUntil` from @sentry/utils\n   */\n  protected _disabledUntil(requestType: SentryRequestType): Date {\n    const category = requestTypeToCategory(requestType);\n    return new Date(disabledUntil(this._rateLimits, category));\n  }\n\n  /**\n   * Checks if a category is rate limited\n   *\n   * @deprecated Please use `isRateLimited` from @sentry/utils\n   */\n  protected _isRateLimited(requestType: SentryRequestType): boolean {\n    const category = requestTypeToCategory(requestType);\n    return isRateLimited(this._rateLimits, category);\n  }\n\n  protected abstract _sendRequest(\n    sentryRequest: SentryRequest,\n    originalPayload: Event | Session,\n  ): PromiseLike<SentryResponse>;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}