{"ast":null,"code":"import { dropUndefinedKeys, logger } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getCurrentHub } from './hub';\n/**\n * @inheritdoc\n */\nvar SessionFlusher = /** @class */function () {\n  function SessionFlusher(transport, attrs) {\n    var _this = this;\n    this.flushTimeout = 60;\n    this._pendingAggregates = {};\n    this._isEnabled = true;\n    this._transport = transport;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(function () {\n      return _this.flush();\n    }, this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n  /** Sends session aggregates to Transport */\n  SessionFlusher.prototype.sendSessionAggregates = function (sessionAggregates) {\n    if (!this._transport.sendSession) {\n      IS_DEBUG_BUILD && logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n    void this._transport.sendSession(sessionAggregates).then(null, function (reason) {\n      IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n    });\n  };\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n  SessionFlusher.prototype.flush = function () {\n    var sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  };\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  SessionFlusher.prototype.getSessionAggregates = function () {\n    var _this = this;\n    var aggregates = Object.keys(this._pendingAggregates).map(function (key) {\n      return _this._pendingAggregates[parseInt(key)];\n    });\n    var sessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates: aggregates\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  };\n  /** JSDoc */\n  SessionFlusher.prototype.close = function () {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  };\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  SessionFlusher.prototype.incrementSessionStatusCount = function () {\n    if (!this._isEnabled) {\n      return;\n    }\n    var scope = getCurrentHub().getScope();\n    var requestSession = scope && scope.getRequestSession();\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      if (scope) {\n        scope.setRequestSession(undefined);\n      }\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  };\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  SessionFlusher.prototype._incrementSessionStatusCount = function (status, date) {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    var sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    var aggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  };\n  return SessionFlusher;\n}();\nexport { SessionFlusher };","map":{"version":3,"names":["dropUndefinedKeys","logger","IS_DEBUG_BUILD","getCurrentHub","SessionFlusher","transport","attrs","_this","flushTimeout","_pendingAggregates","_isEnabled","_transport","_intervalId","setInterval","flush","_sessionAttrs","prototype","sendSessionAggregates","sessionAggregates","sendSession","warn","then","reason","error","getSessionAggregates","aggregates","length","Object","keys","map","key","parseInt","close","clearInterval","incrementSessionStatusCount","scope","getScope","requestSession","getRequestSession","status","_incrementSessionStatusCount","Date","setRequestSession","undefined","date","sessionStartedTrunc","setSeconds","aggregationCounts","started","toISOString","errored","exited","crashed"],"sources":["../../src/sessionflusher.ts"],"sourcesContent":["import {\n  AggregationCounts,\n  RequestSessionStatus,\n  SessionAggregates,\n  SessionFlusherLike,\n  Transport,\n} from '@sentry/types';\nimport { dropUndefinedKeys, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getCurrentHub } from './hub';\n\ntype ReleaseHealthAttributes = {\n  environment?: string;\n  release: string;\n};\n\n/**\n * @inheritdoc\n */\nexport class SessionFlusher implements SessionFlusherLike {\n  public readonly flushTimeout: number = 60;\n  private _pendingAggregates: Record<number, AggregationCounts> = {};\n  private _sessionAttrs: ReleaseHealthAttributes;\n  private _intervalId: ReturnType<typeof setInterval>;\n  private _isEnabled: boolean = true;\n  private _transport: Transport;\n\n  public constructor(transport: Transport, attrs: ReleaseHealthAttributes) {\n    this._transport = transport;\n    // Call to setInterval, so that flush is called every 60 seconds\n    this._intervalId = setInterval(() => this.flush(), this.flushTimeout * 1000);\n    this._sessionAttrs = attrs;\n  }\n\n  /** Sends session aggregates to Transport */\n  public sendSessionAggregates(sessionAggregates: SessionAggregates): void {\n    if (!this._transport.sendSession) {\n      IS_DEBUG_BUILD && logger.warn(\"Dropping session because custom transport doesn't implement sendSession\");\n      return;\n    }\n    void this._transport.sendSession(sessionAggregates).then(null, reason => {\n      IS_DEBUG_BUILD && logger.error('Error while sending session:', reason);\n    });\n  }\n\n  /** Checks if `pendingAggregates` has entries, and if it does flushes them by calling `sendSessions` */\n  public flush(): void {\n    const sessionAggregates = this.getSessionAggregates();\n    if (sessionAggregates.aggregates.length === 0) {\n      return;\n    }\n    this._pendingAggregates = {};\n    this.sendSessionAggregates(sessionAggregates);\n  }\n\n  /** Massages the entries in `pendingAggregates` and returns aggregated sessions */\n  public getSessionAggregates(): SessionAggregates {\n    const aggregates: AggregationCounts[] = Object.keys(this._pendingAggregates).map((key: string) => {\n      return this._pendingAggregates[parseInt(key)];\n    });\n\n    const sessionAggregates: SessionAggregates = {\n      attrs: this._sessionAttrs,\n      aggregates,\n    };\n    return dropUndefinedKeys(sessionAggregates);\n  }\n\n  /** JSDoc */\n  public close(): void {\n    clearInterval(this._intervalId);\n    this._isEnabled = false;\n    this.flush();\n  }\n\n  /**\n   * Wrapper function for _incrementSessionStatusCount that checks if the instance of SessionFlusher is enabled then\n   * fetches the session status of the request from `Scope.getRequestSession().status` on the scope and passes them to\n   * `_incrementSessionStatusCount` along with the start date\n   */\n  public incrementSessionStatusCount(): void {\n    if (!this._isEnabled) {\n      return;\n    }\n    const scope = getCurrentHub().getScope();\n    const requestSession = scope && scope.getRequestSession();\n\n    if (requestSession && requestSession.status) {\n      this._incrementSessionStatusCount(requestSession.status, new Date());\n      // This is not entirely necessarily but is added as a safe guard to indicate the bounds of a request and so in\n      // case captureRequestSession is called more than once to prevent double count\n      if (scope) {\n        scope.setRequestSession(undefined);\n      }\n      /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n    }\n  }\n\n  /**\n   * Increments status bucket in pendingAggregates buffer (internal state) corresponding to status of\n   * the session received\n   */\n  private _incrementSessionStatusCount(status: RequestSessionStatus, date: Date): number {\n    // Truncate minutes and seconds on Session Started attribute to have one minute bucket keys\n    const sessionStartedTrunc = new Date(date).setSeconds(0, 0);\n    this._pendingAggregates[sessionStartedTrunc] = this._pendingAggregates[sessionStartedTrunc] || {};\n\n    // corresponds to aggregated sessions in one specific minute bucket\n    // for example, {\"started\":\"2021-03-16T08:00:00.000Z\",\"exited\":4, \"errored\": 1}\n    const aggregationCounts: AggregationCounts = this._pendingAggregates[sessionStartedTrunc];\n    if (!aggregationCounts.started) {\n      aggregationCounts.started = new Date(sessionStartedTrunc).toISOString();\n    }\n\n    switch (status) {\n      case 'errored':\n        aggregationCounts.errored = (aggregationCounts.errored || 0) + 1;\n        return aggregationCounts.errored;\n      case 'ok':\n        aggregationCounts.exited = (aggregationCounts.exited || 0) + 1;\n        return aggregationCounts.exited;\n      default:\n        aggregationCounts.crashed = (aggregationCounts.crashed || 0) + 1;\n        return aggregationCounts.crashed;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}