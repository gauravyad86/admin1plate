{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { SentryError, SyncPromise } from '@sentry/utils';\nimport { BaseTransport } from './base';\n/** `XHR` based transport */\nvar XHRTransport = /** @class */function (_super) {\n  __extends(XHRTransport, _super);\n  function XHRTransport() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @param sentryRequest Prepared SentryRequest to be delivered\n   * @param originalPayload Original payload used to create SentryRequest\n   */\n  XHRTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {\n    var _this = this;\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._isRateLimited(sentryRequest.type)) {\n      this.recordLostEvent('ratelimit_backoff', sentryRequest.type);\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        // eslint-disable-next-line deprecation/deprecation\n        reason: \"Transport for \" + sentryRequest.type + \" requests locked till \" + this._disabledUntil(sentryRequest.type) + \" due to too many requests.\",\n        status: 429\n      });\n    }\n    return this._buffer.add(function () {\n      return new SyncPromise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n        request.onreadystatechange = function () {\n          if (request.readyState === 4) {\n            var headers = {\n              'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),\n              'retry-after': request.getResponseHeader('Retry-After')\n            };\n            _this._handleResponse({\n              requestType: sentryRequest.type,\n              response: request,\n              headers: headers,\n              resolve: resolve,\n              reject: reject\n            });\n          }\n        };\n        request.open('POST', sentryRequest.url);\n        for (var header in _this.options.headers) {\n          if (Object.prototype.hasOwnProperty.call(_this.options.headers, header)) {\n            request.setRequestHeader(header, _this.options.headers[header]);\n          }\n        }\n        request.send(sentryRequest.body);\n      });\n    }).then(undefined, function (reason) {\n      // It's either buffer rejection or any other xhr/fetch error, which are treated as NetworkError.\n      if (reason instanceof SentryError) {\n        _this.recordLostEvent('queue_overflow', sentryRequest.type);\n      } else {\n        _this.recordLostEvent('network_error', sentryRequest.type);\n      }\n      throw reason;\n    });\n  };\n  return XHRTransport;\n}(BaseTransport);\nexport { XHRTransport };","map":{"version":3,"names":["SentryError","SyncPromise","BaseTransport","XHRTransport","_super","__extends","prototype","_sendRequest","sentryRequest","originalPayload","_this","_isRateLimited","type","recordLostEvent","Promise","reject","event","reason","_disabledUntil","status","_buffer","add","resolve","request","XMLHttpRequest","onreadystatechange","readyState","headers","getResponseHeader","_handleResponse","requestType","response","open","url","header","options","Object","hasOwnProperty","call","setRequestHeader","send","body","then","undefined"],"sources":["../../../../src/transports/xhr.ts"],"sourcesContent":["import { Event, Response, SentryRequest, Session } from '@sentry/types';\nimport { SentryError, SyncPromise } from '@sentry/utils';\n\nimport { BaseTransport } from './base';\n\n/** `XHR` based transport */\nexport class XHRTransport extends BaseTransport {\n  /**\n   * @param sentryRequest Prepared SentryRequest to be delivered\n   * @param originalPayload Original payload used to create SentryRequest\n   */\n  protected _sendRequest(sentryRequest: SentryRequest, originalPayload: Event | Session): PromiseLike<Response> {\n    // eslint-disable-next-line deprecation/deprecation\n    if (this._isRateLimited(sentryRequest.type)) {\n      this.recordLostEvent('ratelimit_backoff', sentryRequest.type);\n\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        // eslint-disable-next-line deprecation/deprecation\n        reason: `Transport for ${sentryRequest.type} requests locked till ${this._disabledUntil(\n          sentryRequest.type,\n        )} due to too many requests.`,\n        status: 429,\n      });\n    }\n\n    return this._buffer\n      .add(\n        () =>\n          new SyncPromise<Response>((resolve, reject) => {\n            const request = new XMLHttpRequest();\n\n            request.onreadystatechange = (): void => {\n              if (request.readyState === 4) {\n                const headers = {\n                  'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),\n                  'retry-after': request.getResponseHeader('Retry-After'),\n                };\n                this._handleResponse({ requestType: sentryRequest.type, response: request, headers, resolve, reject });\n              }\n            };\n\n            request.open('POST', sentryRequest.url);\n            for (const header in this.options.headers) {\n              if (Object.prototype.hasOwnProperty.call(this.options.headers, header)) {\n                request.setRequestHeader(header, this.options.headers[header]);\n              }\n            }\n            request.send(sentryRequest.body);\n          }),\n      )\n      .then(undefined, reason => {\n        // It's either buffer rejection or any other xhr/fetch error, which are treated as NetworkError.\n        if (reason instanceof SentryError) {\n          this.recordLostEvent('queue_overflow', sentryRequest.type);\n        } else {\n          this.recordLostEvent('network_error', sentryRequest.type);\n        }\n        throw reason;\n      });\n  }\n}\n"],"mappings":";AACA,SAASA,WAAW,EAAEC,WAAW,QAAQ,eAAe;AAExD,SAASC,aAAa,QAAQ,QAAQ;AAEtC;AACA,IAAAC,YAAA,0BAAAC,MAAA;EAAkCC,SAAA,CAAAF,YAAA,EAAAC,MAAA;EAAlC,SAAAD,aAAA;;EAwDA;EAvDE;;;;EAIUA,YAAA,CAAAG,SAAA,CAAAC,YAAY,GAAtB,UAAuBC,aAA4B,EAAEC,eAAgC;IAArF,IAAAC,KAAA;IACE;IACA,IAAI,IAAI,CAACC,cAAc,CAACH,aAAa,CAACI,IAAI,CAAC,EAAE;MAC3C,IAAI,CAACC,eAAe,CAAC,mBAAmB,EAAEL,aAAa,CAACI,IAAI,CAAC;MAE7D,OAAOE,OAAO,CAACC,MAAM,CAAC;QACpBC,KAAK,EAAEP,eAAe;QACtBG,IAAI,EAAEJ,aAAa,CAACI,IAAI;QACxB;QACAK,MAAM,EAAE,mBAAiBT,aAAa,CAACI,IAAI,8BAAyB,IAAI,CAACM,cAAc,CACrFV,aAAa,CAACI,IAAI,CACnB,+BAA4B;QAC7BO,MAAM,EAAE;OACT,CAAC;;IAGJ,OAAO,IAAI,CAACC,OAAO,CAChBC,GAAG,CACF;MACE,WAAIpB,WAAW,CAAW,UAACqB,OAAO,EAAEP,MAAM;QACxC,IAAMQ,OAAO,GAAG,IAAIC,cAAc,EAAE;QAEpCD,OAAO,CAACE,kBAAkB,GAAG;UAC3B,IAAIF,OAAO,CAACG,UAAU,KAAK,CAAC,EAAE;YAC5B,IAAMC,OAAO,GAAG;cACd,sBAAsB,EAAEJ,OAAO,CAACK,iBAAiB,CAAC,sBAAsB,CAAC;cACzE,aAAa,EAAEL,OAAO,CAACK,iBAAiB,CAAC,aAAa;aACvD;YACDlB,KAAI,CAACmB,eAAe,CAAC;cAAEC,WAAW,EAAEtB,aAAa,CAACI,IAAI;cAAEmB,QAAQ,EAAER,OAAO;cAAEI,OAAO,EAAAA,OAAA;cAAEL,OAAO,EAAAA,OAAA;cAAEP,MAAM,EAAAA;YAAA,CAAE,CAAC;;QAE1G,CAAC;QAEDQ,OAAO,CAACS,IAAI,CAAC,MAAM,EAAExB,aAAa,CAACyB,GAAG,CAAC;QACvC,KAAK,IAAMC,MAAM,IAAIxB,KAAI,CAACyB,OAAO,CAACR,OAAO,EAAE;UACzC,IAAIS,MAAM,CAAC9B,SAAS,CAAC+B,cAAc,CAACC,IAAI,CAAC5B,KAAI,CAACyB,OAAO,CAACR,OAAO,EAAEO,MAAM,CAAC,EAAE;YACtEX,OAAO,CAACgB,gBAAgB,CAACL,MAAM,EAAExB,KAAI,CAACyB,OAAO,CAACR,OAAO,CAACO,MAAM,CAAC,CAAC;;;QAGlEX,OAAO,CAACiB,IAAI,CAAChC,aAAa,CAACiC,IAAI,CAAC;MAClC,CAAC,CAAC;IApBF,CAoBE,CACL,CACAC,IAAI,CAACC,SAAS,EAAE,UAAA1B,MAAM;MACrB;MACA,IAAIA,MAAM,YAAYjB,WAAW,EAAE;QACjCU,KAAI,CAACG,eAAe,CAAC,gBAAgB,EAAEL,aAAa,CAACI,IAAI,CAAC;OAC3D,MAAM;QACLF,KAAI,CAACG,eAAe,CAAC,eAAe,EAAEL,aAAa,CAACI,IAAI,CAAC;;MAE3D,MAAMK,MAAM;IACd,CAAC,CAAC;EACN,CAAC;EACH,OAAAd,YAAC;AAAD,CAAC,CAxDiCD,aAAa"},"metadata":{},"sourceType":"module"}