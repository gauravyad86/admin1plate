{"ast":null,"code":"import { forget, getGlobalObject, isNativeFetch, logger, supportsFetch } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from '../flags';\nvar global = getGlobalObject();\nvar cachedFetchImpl;\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nexport function getNativeFetchImplementation() {\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n  /* eslint-disable @typescript-eslint/unbound-method */\n  // Fast path to avoid DOM I/O\n  if (isNativeFetch(global.fetch)) {\n    return cachedFetchImpl = global.fetch.bind(global);\n  }\n  var document = global.document;\n  var fetchImpl = global.fetch;\n  // eslint-disable-next-line deprecation/deprecation\n  if (document && typeof document.createElement === 'function') {\n    try {\n      var sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      var contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.fetch) {\n        fetchImpl = contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      IS_DEBUG_BUILD && logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n  return cachedFetchImpl = fetchImpl.bind(global);\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n/**\n * Sends sdk client report using sendBeacon or fetch as a fallback if available\n *\n * @param url report endpoint\n * @param body report payload\n */\nexport function sendReport(url, body) {\n  var isRealNavigator = Object.prototype.toString.call(global && global.navigator) === '[object Navigator]';\n  var hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === 'function';\n  if (hasSendBeacon) {\n    // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch\n    var sendBeacon = global.navigator.sendBeacon.bind(global.navigator);\n    return sendBeacon(url, body);\n  }\n  if (supportsFetch()) {\n    var fetch_1 = getNativeFetchImplementation();\n    return forget(fetch_1(url, {\n      body: body,\n      method: 'POST',\n      credentials: 'omit',\n      keepalive: true\n    }));\n  }\n}","map":{"version":3,"names":["forget","getGlobalObject","isNativeFetch","logger","supportsFetch","IS_DEBUG_BUILD","global","cachedFetchImpl","getNativeFetchImplementation","fetch","bind","document","fetchImpl","createElement","sandbox","hidden","head","appendChild","contentWindow","removeChild","e","warn","sendReport","url","body","isRealNavigator","Object","prototype","toString","call","navigator","hasSendBeacon","sendBeacon","fetch_1","method","credentials","keepalive"],"sources":["../../../../src/transports/utils.ts"],"sourcesContent":["import { forget, getGlobalObject, isNativeFetch, logger, supportsFetch } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../flags';\n\nconst global = getGlobalObject<Window>();\nlet cachedFetchImpl: FetchImpl;\n\nexport type FetchImpl = typeof fetch;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nexport function getNativeFetchImplementation(): FetchImpl {\n  if (cachedFetchImpl) {\n    return cachedFetchImpl;\n  }\n\n  /* eslint-disable @typescript-eslint/unbound-method */\n\n  // Fast path to avoid DOM I/O\n  if (isNativeFetch(global.fetch)) {\n    return (cachedFetchImpl = global.fetch.bind(global));\n  }\n\n  const document = global.document;\n  let fetchImpl = global.fetch;\n  // eslint-disable-next-line deprecation/deprecation\n  if (document && typeof document.createElement === 'function') {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      const contentWindow = sandbox.contentWindow;\n      if (contentWindow && contentWindow.fetch) {\n        fetchImpl = contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      IS_DEBUG_BUILD &&\n        logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return (cachedFetchImpl = fetchImpl.bind(global));\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n\n/**\n * Sends sdk client report using sendBeacon or fetch as a fallback if available\n *\n * @param url report endpoint\n * @param body report payload\n */\nexport function sendReport(url: string, body: string): void {\n  const isRealNavigator = Object.prototype.toString.call(global && global.navigator) === '[object Navigator]';\n  const hasSendBeacon = isRealNavigator && typeof global.navigator.sendBeacon === 'function';\n\n  if (hasSendBeacon) {\n    // Prevent illegal invocations - https://xgwang.me/posts/you-may-not-know-beacon/#it-may-throw-error%2C-be-sure-to-catch\n    const sendBeacon = global.navigator.sendBeacon.bind(global.navigator);\n    return sendBeacon(url, body);\n  }\n\n  if (supportsFetch()) {\n    const fetch = getNativeFetchImplementation();\n    return forget(\n      fetch(url, {\n        body,\n        method: 'POST',\n        credentials: 'omit',\n        keepalive: true,\n      }),\n    );\n  }\n}\n"],"mappings":"AAAA,SAASA,MAAM,EAAEC,eAAe,EAAEC,aAAa,EAAEC,MAAM,EAAEC,aAAa,QAAQ,eAAe;AAE7F,SAASC,cAAc,QAAQ,UAAU;AAEzC,IAAMC,MAAM,GAAGL,eAAe,EAAU;AACxC,IAAIM,eAA0B;AAI9B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsCA,OAAM,SAAUC,4BAA4BA,CAAA;EAC1C,IAAID,eAAe,EAAE;IACnB,OAAOA,eAAe;;EAGxB;EAEA;EACA,IAAIL,aAAa,CAACI,MAAM,CAACG,KAAK,CAAC,EAAE;IAC/B,OAAQF,eAAe,GAAGD,MAAM,CAACG,KAAK,CAACC,IAAI,CAACJ,MAAM,CAAC;;EAGrD,IAAMK,QAAQ,GAAGL,MAAM,CAACK,QAAQ;EAChC,IAAIC,SAAS,GAAGN,MAAM,CAACG,KAAK;EAC5B;EACA,IAAIE,QAAQ,IAAI,OAAOA,QAAQ,CAACE,aAAa,KAAK,UAAU,EAAE;IAC5D,IAAI;MACF,IAAMC,OAAO,GAAGH,QAAQ,CAACE,aAAa,CAAC,QAAQ,CAAC;MAChDC,OAAO,CAACC,MAAM,GAAG,IAAI;MACrBJ,QAAQ,CAACK,IAAI,CAACC,WAAW,CAACH,OAAO,CAAC;MAClC,IAAMI,aAAa,GAAGJ,OAAO,CAACI,aAAa;MAC3C,IAAIA,aAAa,IAAIA,aAAa,CAACT,KAAK,EAAE;QACxCG,SAAS,GAAGM,aAAa,CAACT,KAAK;;MAEjCE,QAAQ,CAACK,IAAI,CAACG,WAAW,CAACL,OAAO,CAAC;KACnC,CAAC,OAAOM,CAAC,EAAE;MACVf,cAAc,IACZF,MAAM,CAACkB,IAAI,CAAC,iFAAiF,EAAED,CAAC,CAAC;;;EAIvG,OAAQb,eAAe,GAAGK,SAAS,CAACF,IAAI,CAACJ,MAAM,CAAC;EAChD;AACF;AAEA;;;;;;AAMA,OAAM,SAAUgB,UAAUA,CAACC,GAAW,EAAEC,IAAY;EAClD,IAAMC,eAAe,GAAGC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACvB,MAAM,IAAIA,MAAM,CAACwB,SAAS,CAAC,KAAK,oBAAoB;EAC3G,IAAMC,aAAa,GAAGN,eAAe,IAAI,OAAOnB,MAAM,CAACwB,SAAS,CAACE,UAAU,KAAK,UAAU;EAE1F,IAAID,aAAa,EAAE;IACjB;IACA,IAAMC,UAAU,GAAG1B,MAAM,CAACwB,SAAS,CAACE,UAAU,CAACtB,IAAI,CAACJ,MAAM,CAACwB,SAAS,CAAC;IACrE,OAAOE,UAAU,CAACT,GAAG,EAAEC,IAAI,CAAC;;EAG9B,IAAIpB,aAAa,EAAE,EAAE;IACnB,IAAM6B,OAAK,GAAGzB,4BAA4B,EAAE;IAC5C,OAAOR,MAAM,CACXiC,OAAK,CAACV,GAAG,EAAE;MACTC,IAAI,EAAAA,IAAA;MACJU,MAAM,EAAE,MAAM;MACdC,WAAW,EAAE,MAAM;MACnBC,SAAS,EAAE;KACZ,CAAC,CACH;;AAEL"},"metadata":{},"sourceType":"module"}