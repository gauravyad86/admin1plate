{"ast":null,"code":"import { __assign, __values } from \"tslib\";\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject } from './global';\nimport { isInstanceOf, isString } from './is';\nimport { CONSOLE_LEVELS, logger } from './logger';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\nvar global = getGlobalObject();\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\nvar handlers = {};\nvar instrumented = {};\n/** Instruments given API */\nfunction instrument(type) {\n  if (instrumented[type]) {\n    return;\n  }\n  instrumented[type] = true;\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      IS_DEBUG_BUILD && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(type, callback) {\n  handlers[type] = handlers[type] || [];\n  handlers[type].push(callback);\n  instrument(type);\n}\n/** JSDoc */\nfunction triggerHandlers(type, data) {\n  var e_1, _a;\n  if (!type || !handlers[type]) {\n    return;\n  }\n  try {\n    for (var _b = __values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {\n      var handler = _c.value;\n      try {\n        handler(data);\n      } catch (e) {\n        IS_DEBUG_BUILD && logger.error(\"Error while triggering instrumentation handler.\\nType: \" + type + \"\\nName: \" + getFunctionName(handler) + \"\\nError:\", e);\n      }\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n}\n/** JSDoc */\nfunction instrumentConsole() {\n  if (!('console' in global)) {\n    return;\n  }\n  CONSOLE_LEVELS.forEach(function (level) {\n    if (!(level in global.console)) {\n      return;\n    }\n    fill(global.console, level, function (originalConsoleMethod) {\n      return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        triggerHandlers('console', {\n          args: args,\n          level: level\n        });\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(global.console, args);\n        }\n      };\n    });\n  });\n}\n/** JSDoc */\nfunction instrumentFetch() {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n  fill(global, 'fetch', function (originalFetch) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var handlerData = {\n        args: args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args)\n        },\n        startTimestamp: Date.now()\n      };\n      triggerHandlers('fetch', __assign({}, handlerData));\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(global, args).then(function (response) {\n        triggerHandlers('fetch', __assign(__assign({}, handlerData), {\n          endTimestamp: Date.now(),\n          response: response\n        }));\n        return response;\n      }, function (error) {\n        triggerHandlers('fetch', __assign(__assign({}, handlerData), {\n          endTimestamp: Date.now(),\n          error: error\n        }));\n        // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n        //       it means the sentry.javascript SDK caught an error invoking your application code.\n        //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n        throw error;\n      });\n    };\n  });\n}\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs) {\n  if (fetchArgs === void 0) {\n    fetchArgs = [];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs) {\n  if (fetchArgs === void 0) {\n    fetchArgs = [];\n  }\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n/** JSDoc */\nfunction instrumentXHR() {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n  var xhrproto = XMLHttpRequest.prototype;\n  fill(xhrproto, 'open', function (originalOpen) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var xhr = this;\n      var url = args[1];\n      var xhrInfo = xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1]\n      };\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n      var onreadystatechangeHandler = function () {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhr.status;\n          } catch (e) {\n            /* do nothing */\n          }\n          triggerHandlers('xhr', {\n            args: args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr: xhr\n          });\n        }\n      };\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original) {\n          return function () {\n            var readyStateArgs = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n              readyStateArgs[_i] = arguments[_i];\n            }\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n      return originalOpen.apply(xhr, args);\n    };\n  });\n  fill(xhrproto, 'send', function (originalSend) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      if (this.__sentry_xhr__ && args[0] !== undefined) {\n        this.__sentry_xhr__.body = args[0];\n      }\n      triggerHandlers('xhr', {\n        args: args,\n        startTimestamp: Date.now(),\n        xhr: this\n      });\n      return originalSend.apply(this, args);\n    };\n  });\n}\nvar lastHref;\n/** JSDoc */\nfunction instrumentHistory() {\n  if (!supportsHistory()) {\n    return;\n  }\n  var oldOnPopState = global.onpopstate;\n  global.onpopstate = function () {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n    var to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    var from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from: from,\n      to: to\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction) {\n    return function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      var url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        var from = lastHref;\n        var to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from: from,\n          to: to\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\nvar debounceDuration = 1000;\nvar debounceTimerID;\nvar lastCapturedEvent;\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous, current) {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event) {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n  try {\n    var target = event.target;\n    if (!target || !target.tagName) {\n      return true;\n    }\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n  return true;\n}\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler, globalListener) {\n  if (globalListener === void 0) {\n    globalListener = false;\n  }\n  return function (event) {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n    var name = event.type === 'keypress' ? 'input' : event.type;\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name: name,\n        global: globalListener\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name: name,\n        global: globalListener\n      });\n      lastCapturedEvent = event;\n    }\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = global.setTimeout(function () {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n/** JSDoc */\nfunction instrumentDOM() {\n  if (!('document' in global)) {\n    return;\n  }\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  var triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  global.document.addEventListener('click', globalDOMEventHandler, false);\n  global.document.addEventListener('keypress', globalDOMEventHandler, false);\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach(function (target) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    var proto = global[target] && global[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n    fill(proto, 'addEventListener', function (originalAddEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            var el = this;\n            var handlers_1 = el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {};\n            var handlerForType = handlers_1[type] = handlers_1[type] || {\n              refCount: 0\n            };\n            if (!handlerForType.handler) {\n              var handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n            handlerForType.refCount += 1;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n    fill(proto, 'removeEventListener', function (originalRemoveEventListener) {\n      return function (type, listener, options) {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            var el = this;\n            var handlers_2 = el.__sentry_instrumentation_handlers__ || {};\n            var handlerForType = handlers_2[type];\n            if (handlerForType) {\n              handlerForType.refCount -= 1;\n              // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n              if (handlerForType.refCount <= 0) {\n                originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                handlerForType.handler = undefined;\n                delete handlers_2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n              }\n              // If there are no longer any custom handlers of any type on this element, cleanup everything.\n              if (Object.keys(handlers_2).length === 0) {\n                delete el.__sentry_instrumentation_handlers__;\n              }\n            }\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n        return originalRemoveEventListener.call(this, type, listener, options);\n      };\n    });\n  });\n}\nvar _oldOnErrorHandler = null;\n/** JSDoc */\nfunction instrumentError() {\n  _oldOnErrorHandler = global.onerror;\n  global.onerror = function (msg, url, line, column, error) {\n    triggerHandlers('error', {\n      column: column,\n      error: error,\n      line: line,\n      msg: msg,\n      url: url\n    });\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n    return false;\n  };\n}\nvar _oldOnUnhandledRejectionHandler = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection() {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n  global.onunhandledrejection = function (e) {\n    triggerHandlers('unhandledrejection', e);\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n    return true;\n  };\n}","map":{"version":3,"names":["IS_DEBUG_BUILD","getGlobalObject","isInstanceOf","isString","CONSOLE_LEVELS","logger","fill","getFunctionName","supportsHistory","supportsNativeFetch","global","handlers","instrumented","instrument","type","instrumentConsole","instrumentDOM","instrumentXHR","instrumentFetch","instrumentHistory","instrumentError","instrumentUnhandledRejection","warn","addInstrumentationHandler","callback","push","triggerHandlers","data","_b","__values","_c","next","done","handler","value","e","error","forEach","level","console","originalConsoleMethod","args","_i","arguments","length","apply","originalFetch","handlerData","fetchData","method","getFetchMethod","url","getFetchUrl","startTimestamp","Date","now","__assign","then","response","endTimestamp","fetchArgs","Request","String","toUpperCase","xhrproto","XMLHttpRequest","prototype","originalOpen","xhr","xhrInfo","__sentry_xhr__","match","__sentry_own_request__","onreadystatechangeHandler","readyState","status_code","status","onreadystatechange","original","readyStateArgs","addEventListener","originalSend","undefined","body","lastHref","oldOnPopState","onpopstate","to","location","href","from","_oO","historyReplacementFunction","originalHistoryFunction","history","debounceDuration","debounceTimerID","lastCapturedEvent","shouldShortcircuitPreviousDebounce","previous","current","target","shouldSkipDOMEvent","event","tagName","isContentEditable","makeDOMEventHandler","globalListener","name","clearTimeout","setTimeout","triggerDOMHandler","bind","globalDOMEventHandler","document","proto","hasOwnProperty","originalAddEventListener","listener","options","el","handlers_1","__sentry_instrumentation_handlers__","handlerForType","refCount","call","originalRemoveEventListener","handlers_2","Object","keys","_oldOnErrorHandler","onerror","msg","line","column","_oldOnUnhandledRejectionHandler","onunhandledrejection"],"sources":["../../src/instrument.ts"],"sourcesContent":["/* eslint-disable max-lines */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/ban-types */\nimport { WrappedFunction } from '@sentry/types';\n\nimport { IS_DEBUG_BUILD } from './flags';\nimport { getGlobalObject } from './global';\nimport { isInstanceOf, isString } from './is';\nimport { CONSOLE_LEVELS, logger } from './logger';\nimport { fill } from './object';\nimport { getFunctionName } from './stacktrace';\nimport { supportsHistory, supportsNativeFetch } from './supports';\n\nconst global = getGlobalObject<Window>();\n\ntype InstrumentHandlerType =\n  | 'console'\n  | 'dom'\n  | 'fetch'\n  | 'history'\n  | 'sentry'\n  | 'xhr'\n  | 'error'\n  | 'unhandledrejection';\ntype InstrumentHandlerCallback = (data: any) => void;\n\n/**\n * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.\n *  - Console API\n *  - Fetch API\n *  - XHR API\n *  - History API\n *  - DOM API (click/typing)\n *  - Error API\n *  - UnhandledRejection API\n */\n\nconst handlers: { [key in InstrumentHandlerType]?: InstrumentHandlerCallback[] } = {};\nconst instrumented: { [key in InstrumentHandlerType]?: boolean } = {};\n\n/** Instruments given API */\nfunction instrument(type: InstrumentHandlerType): void {\n  if (instrumented[type]) {\n    return;\n  }\n\n  instrumented[type] = true;\n\n  switch (type) {\n    case 'console':\n      instrumentConsole();\n      break;\n    case 'dom':\n      instrumentDOM();\n      break;\n    case 'xhr':\n      instrumentXHR();\n      break;\n    case 'fetch':\n      instrumentFetch();\n      break;\n    case 'history':\n      instrumentHistory();\n      break;\n    case 'error':\n      instrumentError();\n      break;\n    case 'unhandledrejection':\n      instrumentUnhandledRejection();\n      break;\n    default:\n      IS_DEBUG_BUILD && logger.warn('unknown instrumentation type:', type);\n      return;\n  }\n}\n\n/**\n * Add handler that will be called when given type of instrumentation triggers.\n * Use at your own risk, this might break without changelog notice, only used internally.\n * @hidden\n */\nexport function addInstrumentationHandler(type: InstrumentHandlerType, callback: InstrumentHandlerCallback): void {\n  handlers[type] = handlers[type] || [];\n  (handlers[type] as InstrumentHandlerCallback[]).push(callback);\n  instrument(type);\n}\n\n/** JSDoc */\nfunction triggerHandlers(type: InstrumentHandlerType, data: any): void {\n  if (!type || !handlers[type]) {\n    return;\n  }\n\n  for (const handler of handlers[type] || []) {\n    try {\n      handler(data);\n    } catch (e) {\n      IS_DEBUG_BUILD &&\n        logger.error(\n          `Error while triggering instrumentation handler.\\nType: ${type}\\nName: ${getFunctionName(handler)}\\nError:`,\n          e,\n        );\n    }\n  }\n}\n\n/** JSDoc */\nfunction instrumentConsole(): void {\n  if (!('console' in global)) {\n    return;\n  }\n\n  CONSOLE_LEVELS.forEach(function (level: string): void {\n    if (!(level in global.console)) {\n      return;\n    }\n\n    fill(global.console, level, function (originalConsoleMethod: () => any): Function {\n      return function (...args: any[]): void {\n        triggerHandlers('console', { args, level });\n\n        // this fails for some browsers. :(\n        if (originalConsoleMethod) {\n          originalConsoleMethod.apply(global.console, args);\n        }\n      };\n    });\n  });\n}\n\n/** JSDoc */\nfunction instrumentFetch(): void {\n  if (!supportsNativeFetch()) {\n    return;\n  }\n\n  fill(global, 'fetch', function (originalFetch: () => void): () => void {\n    return function (...args: any[]): void {\n      const handlerData = {\n        args,\n        fetchData: {\n          method: getFetchMethod(args),\n          url: getFetchUrl(args),\n        },\n        startTimestamp: Date.now(),\n      };\n\n      triggerHandlers('fetch', {\n        ...handlerData,\n      });\n\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      return originalFetch.apply(global, args).then(\n        (response: Response) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            response,\n          });\n          return response;\n        },\n        (error: Error) => {\n          triggerHandlers('fetch', {\n            ...handlerData,\n            endTimestamp: Date.now(),\n            error,\n          });\n          // NOTE: If you are a Sentry user, and you are seeing this stack frame,\n          //       it means the sentry.javascript SDK caught an error invoking your application code.\n          //       This is expected behavior and NOT indicative of a bug with sentry.javascript.\n          throw error;\n        },\n      );\n    };\n  });\n}\n\ntype XHRSendInput = null | Blob | BufferSource | FormData | URLSearchParams | string;\n\n/** JSDoc */\ninterface SentryWrappedXMLHttpRequest extends XMLHttpRequest {\n  [key: string]: any;\n  __sentry_xhr__?: {\n    method?: string;\n    url?: string;\n    status_code?: number;\n    body?: XHRSendInput;\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-unsafe-member-access */\n/** Extract `method` from fetch call arguments */\nfunction getFetchMethod(fetchArgs: any[] = []): string {\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {\n    return String(fetchArgs[0].method).toUpperCase();\n  }\n  if (fetchArgs[1] && fetchArgs[1].method) {\n    return String(fetchArgs[1].method).toUpperCase();\n  }\n  return 'GET';\n}\n\n/** Extract `url` from fetch call arguments */\nfunction getFetchUrl(fetchArgs: any[] = []): string {\n  if (typeof fetchArgs[0] === 'string') {\n    return fetchArgs[0];\n  }\n  if ('Request' in global && isInstanceOf(fetchArgs[0], Request)) {\n    return fetchArgs[0].url;\n  }\n  return String(fetchArgs[0]);\n}\n/* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n/** JSDoc */\nfunction instrumentXHR(): void {\n  if (!('XMLHttpRequest' in global)) {\n    return;\n  }\n\n  const xhrproto = XMLHttpRequest.prototype;\n\n  fill(xhrproto, 'open', function (originalOpen: () => void): () => void {\n    return function (this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const xhr = this;\n      const url = args[1];\n      const xhrInfo: SentryWrappedXMLHttpRequest['__sentry_xhr__'] = (xhr.__sentry_xhr__ = {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        method: isString(args[0]) ? args[0].toUpperCase() : args[0],\n        url: args[1],\n      });\n\n      // if Sentry key appears in URL, don't capture it as a request\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (isString(url) && xhrInfo.method === 'POST' && url.match(/sentry_key/)) {\n        xhr.__sentry_own_request__ = true;\n      }\n\n      const onreadystatechangeHandler = function (): void {\n        if (xhr.readyState === 4) {\n          try {\n            // touching statusCode in some platforms throws\n            // an exception\n            xhrInfo.status_code = xhr.status;\n          } catch (e) {\n            /* do nothing */\n          }\n\n          triggerHandlers('xhr', {\n            args,\n            endTimestamp: Date.now(),\n            startTimestamp: Date.now(),\n            xhr,\n          });\n        }\n      };\n\n      if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {\n        fill(xhr, 'onreadystatechange', function (original: WrappedFunction): Function {\n          return function (...readyStateArgs: any[]): void {\n            onreadystatechangeHandler();\n            return original.apply(xhr, readyStateArgs);\n          };\n        });\n      } else {\n        xhr.addEventListener('readystatechange', onreadystatechangeHandler);\n      }\n\n      return originalOpen.apply(xhr, args);\n    };\n  });\n\n  fill(xhrproto, 'send', function (originalSend: () => void): () => void {\n    return function (this: SentryWrappedXMLHttpRequest, ...args: any[]): void {\n      if (this.__sentry_xhr__ && args[0] !== undefined) {\n        this.__sentry_xhr__.body = args[0];\n      }\n\n      triggerHandlers('xhr', {\n        args,\n        startTimestamp: Date.now(),\n        xhr: this,\n      });\n\n      return originalSend.apply(this, args);\n    };\n  });\n}\n\nlet lastHref: string;\n\n/** JSDoc */\nfunction instrumentHistory(): void {\n  if (!supportsHistory()) {\n    return;\n  }\n\n  const oldOnPopState = global.onpopstate;\n  global.onpopstate = function (this: WindowEventHandlers, ...args: any[]): any {\n    const to = global.location.href;\n    // keep track of the current URL state, as we always receive only the updated state\n    const from = lastHref;\n    lastHref = to;\n    triggerHandlers('history', {\n      from,\n      to,\n    });\n    if (oldOnPopState) {\n      // Apparently this can throw in Firefox when incorrectly implemented plugin is installed.\n      // https://github.com/getsentry/sentry-javascript/issues/3344\n      // https://github.com/bugsnag/bugsnag-js/issues/469\n      try {\n        return oldOnPopState.apply(this, args);\n      } catch (_oO) {\n        // no-empty\n      }\n    }\n  };\n\n  /** @hidden */\n  function historyReplacementFunction(originalHistoryFunction: () => void): () => void {\n    return function (this: History, ...args: any[]): void {\n      const url = args.length > 2 ? args[2] : undefined;\n      if (url) {\n        // coerce to string (this is what pushState does)\n        const from = lastHref;\n        const to = String(url);\n        // keep track of the current URL state, as we always receive only the updated state\n        lastHref = to;\n        triggerHandlers('history', {\n          from,\n          to,\n        });\n      }\n      return originalHistoryFunction.apply(this, args);\n    };\n  }\n\n  fill(global.history, 'pushState', historyReplacementFunction);\n  fill(global.history, 'replaceState', historyReplacementFunction);\n}\n\nconst debounceDuration = 1000;\nlet debounceTimerID: number | undefined;\nlet lastCapturedEvent: Event | undefined;\n\n/**\n * Decide whether the current event should finish the debounce of previously captured one.\n * @param previous previously captured event\n * @param current event to be captured\n */\nfunction shouldShortcircuitPreviousDebounce(previous: Event | undefined, current: Event): boolean {\n  // If there was no previous event, it should always be swapped for the new one.\n  if (!previous) {\n    return true;\n  }\n\n  // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.\n  if (previous.type !== current.type) {\n    return true;\n  }\n\n  try {\n    // If both events have the same type, it's still possible that actions were performed on different targets.\n    // e.g. 2 clicks on different buttons.\n    if (previous.target !== current.target) {\n      return true;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_\n  // to which an event listener was attached), we treat them as the same action, as we want to capture\n  // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.\n  return false;\n}\n\n/**\n * Decide whether an event should be captured.\n * @param event event to be captured\n */\nfunction shouldSkipDOMEvent(event: Event): boolean {\n  // We are only interested in filtering `keypress` events for now.\n  if (event.type !== 'keypress') {\n    return false;\n  }\n\n  try {\n    const target = event.target as HTMLElement;\n\n    if (!target || !target.tagName) {\n      return true;\n    }\n\n    // Only consider keypress events on actual input elements. This will disregard keypresses targeting body\n    // e.g.tabbing through elements, hotkeys, etc.\n    if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {\n      return false;\n    }\n  } catch (e) {\n    // just accessing `target` property can throw an exception in some rare circumstances\n    // see: https://github.com/getsentry/sentry-javascript/issues/838\n  }\n\n  return true;\n}\n\n/**\n * Wraps addEventListener to capture UI breadcrumbs\n * @param handler function that will be triggered\n * @param globalListener indicates whether event was captured by the global event listener\n * @returns wrapped breadcrumb events handler\n * @hidden\n */\nfunction makeDOMEventHandler(handler: Function, globalListener: boolean = false): (event: Event) => void {\n  return (event: Event): void => {\n    // It's possible this handler might trigger multiple times for the same\n    // event (e.g. event propagation through node ancestors).\n    // Ignore if we've already captured that event.\n    if (!event || lastCapturedEvent === event) {\n      return;\n    }\n\n    // We always want to skip _some_ events.\n    if (shouldSkipDOMEvent(event)) {\n      return;\n    }\n\n    const name = event.type === 'keypress' ? 'input' : event.type;\n\n    // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.\n    if (debounceTimerID === undefined) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n    // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.\n    // If that's the case, emit the previous event and store locally the newly-captured DOM event.\n    else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {\n      handler({\n        event: event,\n        name,\n        global: globalListener,\n      });\n      lastCapturedEvent = event;\n    }\n\n    // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.\n    clearTimeout(debounceTimerID);\n    debounceTimerID = global.setTimeout(() => {\n      debounceTimerID = undefined;\n    }, debounceDuration);\n  };\n}\n\ntype AddEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | AddEventListenerOptions,\n) => void;\ntype RemoveEventListener = (\n  type: string,\n  listener: EventListenerOrEventListenerObject,\n  options?: boolean | EventListenerOptions,\n) => void;\n\ntype InstrumentedElement = Element & {\n  __sentry_instrumentation_handlers__?: {\n    [key in 'click' | 'keypress']?: {\n      handler?: Function;\n      /** The number of custom listeners attached to this element */\n      refCount: number;\n    };\n  };\n};\n\n/** JSDoc */\nfunction instrumentDOM(): void {\n  if (!('document' in global)) {\n    return;\n  }\n\n  // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom\n  // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before\n  // we instrument `addEventListener` so that we don't end up attaching this handler twice.\n  const triggerDOMHandler = triggerHandlers.bind(null, 'dom');\n  const globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);\n  global.document.addEventListener('click', globalDOMEventHandler, false);\n  global.document.addEventListener('keypress', globalDOMEventHandler, false);\n\n  // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled\n  // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That\n  // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler\n  // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still\n  // guaranteed to fire at least once.)\n  ['EventTarget', 'Node'].forEach((target: string) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const proto = (global as any)[target] && (global as any)[target].prototype;\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins\n    if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {\n      return;\n    }\n\n    fill(proto, 'addEventListener', function (originalAddEventListener: AddEventListener): AddEventListener {\n      return function (\n        this: Element,\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n        options?: boolean | AddEventListenerOptions,\n      ): AddEventListener {\n        if (type === 'click' || type == 'keypress') {\n          try {\n            const el = this as InstrumentedElement;\n            const handlers = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});\n            const handlerForType = (handlers[type] = handlers[type] || { refCount: 0 });\n\n            if (!handlerForType.handler) {\n              const handler = makeDOMEventHandler(triggerDOMHandler);\n              handlerForType.handler = handler;\n              originalAddEventListener.call(this, type, handler, options);\n            }\n\n            handlerForType.refCount += 1;\n          } catch (e) {\n            // Accessing dom properties is always fragile.\n            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n          }\n        }\n\n        return originalAddEventListener.call(this, type, listener, options);\n      };\n    });\n\n    fill(\n      proto,\n      'removeEventListener',\n      function (originalRemoveEventListener: RemoveEventListener): RemoveEventListener {\n        return function (\n          this: Element,\n          type: string,\n          listener: EventListenerOrEventListenerObject,\n          options?: boolean | EventListenerOptions,\n        ): () => void {\n          if (type === 'click' || type == 'keypress') {\n            try {\n              const el = this as InstrumentedElement;\n              const handlers = el.__sentry_instrumentation_handlers__ || {};\n              const handlerForType = handlers[type];\n\n              if (handlerForType) {\n                handlerForType.refCount -= 1;\n                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.\n                if (handlerForType.refCount <= 0) {\n                  originalRemoveEventListener.call(this, type, handlerForType.handler, options);\n                  handlerForType.handler = undefined;\n                  delete handlers[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete\n                }\n\n                // If there are no longer any custom handlers of any type on this element, cleanup everything.\n                if (Object.keys(handlers).length === 0) {\n                  delete el.__sentry_instrumentation_handlers__;\n                }\n              }\n            } catch (e) {\n              // Accessing dom properties is always fragile.\n              // Also allows us to skip `addEventListenrs` calls with no proper `this` context.\n            }\n          }\n\n          return originalRemoveEventListener.call(this, type, listener, options);\n        };\n      },\n    );\n  });\n}\n\nlet _oldOnErrorHandler: OnErrorEventHandler = null;\n/** JSDoc */\nfunction instrumentError(): void {\n  _oldOnErrorHandler = global.onerror;\n\n  global.onerror = function (msg: any, url: any, line: any, column: any, error: any): boolean {\n    triggerHandlers('error', {\n      column,\n      error,\n      line,\n      msg,\n      url,\n    });\n\n    if (_oldOnErrorHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnErrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  };\n}\n\nlet _oldOnUnhandledRejectionHandler: ((e: any) => void) | null = null;\n/** JSDoc */\nfunction instrumentUnhandledRejection(): void {\n  _oldOnUnhandledRejectionHandler = global.onunhandledrejection;\n\n  global.onunhandledrejection = function (e: any): boolean {\n    triggerHandlers('unhandledrejection', e);\n\n    if (_oldOnUnhandledRejectionHandler) {\n      // eslint-disable-next-line prefer-rest-params\n      return _oldOnUnhandledRejectionHandler.apply(this, arguments);\n    }\n\n    return true;\n  };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}