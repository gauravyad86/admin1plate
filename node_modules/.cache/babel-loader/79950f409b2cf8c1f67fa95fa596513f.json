{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from '../../flags';\nvar OPERATIONS = ['aggregate', 'bulkWrite', 'countDocuments', 'createIndex', 'createIndexes', 'deleteMany', 'deleteOne', 'distinct', 'drop', 'dropIndex', 'dropIndexes', 'estimatedDocumentCount', 'find', 'findOne', 'findOneAndDelete', 'findOneAndReplace', 'findOneAndUpdate', 'indexes', 'indexExists', 'indexInformation', 'initializeOrderedBulkOp', 'insertMany', 'insertOne', 'isCapped', 'mapReduce', 'options', 'parallelCollectionScan', 'rename', 'replaceOne', 'stats', 'updateMany', 'updateOne'];\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nvar OPERATION_SIGNATURES = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update']\n};\n/** Tracing integration for mongo package */\nvar Mongo = /** @class */function () {\n  /**\n   * @inheritDoc\n   */\n  function Mongo(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    /**\n     * @inheritDoc\n     */\n    this.name = Mongo.id;\n    this._operations = Array.isArray(options.operations) ? options.operations : OPERATIONS;\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n  /**\n   * @inheritDoc\n   */\n  Mongo.prototype.setupOnce = function (_, getCurrentHub) {\n    var moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    var pkg = loadModule(moduleName);\n    if (!pkg) {\n      IS_DEBUG_BUILD && logger.error(\"Mongo Integration was unable to require `\" + moduleName + \"` package.\");\n      return;\n    }\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  };\n  /**\n   * Patches original collection methods\n   */\n  Mongo.prototype._instrumentOperations = function (collection, operations, getCurrentHub) {\n    var _this = this;\n    operations.forEach(function (operation) {\n      return _this._patchOperation(collection, operation, getCurrentHub);\n    });\n  };\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  Mongo.prototype._patchOperation = function (collection, operation, getCurrentHub) {\n    if (!(operation in collection.prototype)) return;\n    var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n    fill(collection.prototype, operation, function (orig) {\n      return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var _a, _b, _c, _d;\n        var lastArg = args[args.length - 1];\n        var scope = getCurrentHub().getScope();\n        var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || operation === 'mapReduce' && args.length === 2) {\n          var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args));\n          var maybePromise = orig.call.apply(orig, __spread([this], args));\n          if (isThenable(maybePromise)) {\n            return maybePromise.then(function (res) {\n              var _a;\n              (_a = span_1) === null || _a === void 0 ? void 0 : _a.finish();\n              return res;\n            });\n          } else {\n            (_c = span_1) === null || _c === void 0 ? void 0 : _c.finish();\n            return maybePromise;\n          }\n        }\n        var span = (_d = parentSpan) === null || _d === void 0 ? void 0 : _d.startChild(getSpanContext(this, operation, args.slice(0, -1)));\n        return orig.call.apply(orig, __spread([this], args.slice(0, -1), [function (err, result) {\n          var _a;\n          (_a = span) === null || _a === void 0 ? void 0 : _a.finish();\n          lastArg(err, result);\n        }]));\n      };\n    });\n  };\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  Mongo.prototype._getSpanContextFromOperationArguments = function (collection, operation, args) {\n    var data = {\n      collectionName: collection.collectionName,\n      dbName: collection.dbName,\n      namespace: collection.namespace\n    };\n    var spanContext = {\n      op: 'db',\n      description: operation,\n      data: data\n    };\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    var signature = OPERATION_SIGNATURES[operation];\n    var shouldDescribe = Array.isArray(this._describeOperations) ? this._describeOperations.includes(operation) : this._describeOperations;\n    if (!signature || !shouldDescribe) {\n      return spanContext;\n    }\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        var _a = __read(args, 2),\n          map = _a[0],\n          reduce = _a[1];\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (var i = 0; i < signature.length; i++) {\n          data[signature[i]] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n    return spanContext;\n  };\n  /**\n   * @inheritDoc\n   */\n  Mongo.id = 'Mongo';\n  return Mongo;\n}();\nexport { Mongo };","map":{"version":3,"names":["fill","isThenable","loadModule","logger","IS_DEBUG_BUILD","OPERATIONS","OPERATION_SIGNATURES","bulkWrite","countDocuments","createIndex","createIndexes","deleteMany","deleteOne","distinct","dropIndex","find","findOne","findOneAndDelete","findOneAndReplace","findOneAndUpdate","indexExists","insertMany","insertOne","mapReduce","rename","replaceOne","updateMany","updateOne","Mongo","options","name","id","_operations","Array","isArray","operations","_describeOperations","describeOperations","_useMongoose","useMongoose","prototype","setupOnce","_","getCurrentHub","moduleName","pkg","error","_instrumentOperations","Collection","collection","_this","forEach","operation","_patchOperation","getSpanContext","_getSpanContextFromOperationArguments","bind","orig","args","_i","arguments","length","lastArg","scope","getScope","parentSpan","_a","getSpan","span_1","_b","startChild","maybePromise","call","apply","__spread","then","res","finish","_c","span","_d","slice","err","result","data","collectionName","dbName","namespace","spanContext","op","description","signature","shouldDescribe","includes","__read","map","reduce","i","JSON","stringify","_oO"],"sources":["../../../../../src/integrations/node/mongo.ts"],"sourcesContent":["import { Hub } from '@sentry/hub';\nimport { EventProcessor, Integration, SpanContext } from '@sentry/types';\nimport { fill, isThenable, loadModule, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from '../../flags';\n\n// This allows us to use the same array for both defaults options and the type itself.\n// (note `as const` at the end to make it a union of string literal types (i.e. \"a\" | \"b\" | ... )\n// and not just a string[])\ntype Operation = typeof OPERATIONS[number];\nconst OPERATIONS = [\n  'aggregate', // aggregate(pipeline, options, callback)\n  'bulkWrite', // bulkWrite(operations, options, callback)\n  'countDocuments', // countDocuments(query, options, callback)\n  'createIndex', // createIndex(fieldOrSpec, options, callback)\n  'createIndexes', // createIndexes(indexSpecs, options, callback)\n  'deleteMany', // deleteMany(filter, options, callback)\n  'deleteOne', // deleteOne(filter, options, callback)\n  'distinct', // distinct(key, query, options, callback)\n  'drop', // drop(options, callback)\n  'dropIndex', // dropIndex(indexName, options, callback)\n  'dropIndexes', // dropIndexes(options, callback)\n  'estimatedDocumentCount', // estimatedDocumentCount(options, callback)\n  'find', // find(query, options, callback)\n  'findOne', // findOne(query, options, callback)\n  'findOneAndDelete', // findOneAndDelete(filter, options, callback)\n  'findOneAndReplace', // findOneAndReplace(filter, replacement, options, callback)\n  'findOneAndUpdate', // findOneAndUpdate(filter, update, options, callback)\n  'indexes', // indexes(options, callback)\n  'indexExists', // indexExists(indexes, options, callback)\n  'indexInformation', // indexInformation(options, callback)\n  'initializeOrderedBulkOp', // initializeOrderedBulkOp(options, callback)\n  'insertMany', // insertMany(docs, options, callback)\n  'insertOne', // insertOne(doc, options, callback)\n  'isCapped', // isCapped(options, callback)\n  'mapReduce', // mapReduce(map, reduce, options, callback)\n  'options', // options(options, callback)\n  'parallelCollectionScan', // parallelCollectionScan(options, callback)\n  'rename', // rename(newName, options, callback)\n  'replaceOne', // replaceOne(filter, doc, options, callback)\n  'stats', // stats(options, callback)\n  'updateMany', // updateMany(filter, update, options, callback)\n  'updateOne', // updateOne(filter, update, options, callback)\n] as const;\n\n// All of the operations above take `options` and `callback` as their final parameters, but some of them\n// take additional parameters as well. For those operations, this is a map of\n// { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's\n// positional arguments when we add them to the span's `data` object later\nconst OPERATION_SIGNATURES: {\n  [op in Operation]?: string[];\n} = {\n  // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well\n  // see https://github.com/getsentry/sentry-javascript/pull/3102\n  bulkWrite: ['operations'],\n  countDocuments: ['query'],\n  createIndex: ['fieldOrSpec'],\n  createIndexes: ['indexSpecs'],\n  deleteMany: ['filter'],\n  deleteOne: ['filter'],\n  distinct: ['key', 'query'],\n  dropIndex: ['indexName'],\n  find: ['query'],\n  findOne: ['query'],\n  findOneAndDelete: ['filter'],\n  findOneAndReplace: ['filter', 'replacement'],\n  findOneAndUpdate: ['filter', 'update'],\n  indexExists: ['indexes'],\n  insertMany: ['docs'],\n  insertOne: ['doc'],\n  mapReduce: ['map', 'reduce'],\n  rename: ['newName'],\n  replaceOne: ['filter', 'doc'],\n  updateMany: ['filter', 'update'],\n  updateOne: ['filter', 'update'],\n};\n\ninterface MongoCollection {\n  collectionName: string;\n  dbName: string;\n  namespace: string;\n  prototype: {\n    [operation in Operation]: (...args: unknown[]) => unknown;\n  };\n}\n\ninterface MongoOptions {\n  operations?: Operation[];\n  describeOperations?: boolean | Operation[];\n  useMongoose?: boolean;\n}\n\n/** Tracing integration for mongo package */\nexport class Mongo implements Integration {\n  /**\n   * @inheritDoc\n   */\n  public static id: string = 'Mongo';\n\n  /**\n   * @inheritDoc\n   */\n  public name: string = Mongo.id;\n\n  private _operations: Operation[];\n  private _describeOperations?: boolean | Operation[];\n  private _useMongoose: boolean;\n\n  /**\n   * @inheritDoc\n   */\n  public constructor(options: MongoOptions = {}) {\n    this._operations = Array.isArray(options.operations) ? options.operations : (OPERATIONS as unknown as Operation[]);\n    this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;\n    this._useMongoose = !!options.useMongoose;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public setupOnce(_: (callback: EventProcessor) => void, getCurrentHub: () => Hub): void {\n    const moduleName = this._useMongoose ? 'mongoose' : 'mongodb';\n    const pkg = loadModule<{ Collection: MongoCollection }>(moduleName);\n\n    if (!pkg) {\n      IS_DEBUG_BUILD && logger.error(`Mongo Integration was unable to require \\`${moduleName}\\` package.`);\n      return;\n    }\n\n    this._instrumentOperations(pkg.Collection, this._operations, getCurrentHub);\n  }\n\n  /**\n   * Patches original collection methods\n   */\n  private _instrumentOperations(collection: MongoCollection, operations: Operation[], getCurrentHub: () => Hub): void {\n    operations.forEach((operation: Operation) => this._patchOperation(collection, operation, getCurrentHub));\n  }\n\n  /**\n   * Patches original collection to utilize our tracing functionality\n   */\n  private _patchOperation(collection: MongoCollection, operation: Operation, getCurrentHub: () => Hub): void {\n    if (!(operation in collection.prototype)) return;\n\n    const getSpanContext = this._getSpanContextFromOperationArguments.bind(this);\n\n    fill(collection.prototype, operation, function (orig: () => void | Promise<unknown>) {\n      return function (this: unknown, ...args: unknown[]) {\n        const lastArg = args[args.length - 1];\n        const scope = getCurrentHub().getScope();\n        const parentSpan = scope?.getSpan();\n\n        // Check if the operation was passed a callback. (mapReduce requires a different check, as\n        // its (non-callback) arguments can also be functions.)\n        if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {\n          const span = parentSpan?.startChild(getSpanContext(this, operation, args));\n          const maybePromise = orig.call(this, ...args) as Promise<unknown>;\n\n          if (isThenable(maybePromise)) {\n            return maybePromise.then((res: unknown) => {\n              span?.finish();\n              return res;\n            });\n          } else {\n            span?.finish();\n            return maybePromise;\n          }\n        }\n\n        const span = parentSpan?.startChild(getSpanContext(this, operation, args.slice(0, -1)));\n        return orig.call(this, ...args.slice(0, -1), function (err: Error, result: unknown) {\n          span?.finish();\n          lastArg(err, result);\n        });\n      };\n    });\n  }\n\n  /**\n   * Form a SpanContext based on the user input to a given operation.\n   */\n  private _getSpanContextFromOperationArguments(\n    collection: MongoCollection,\n    operation: Operation,\n    args: unknown[],\n  ): SpanContext {\n    const data: { [key: string]: string } = {\n      collectionName: collection.collectionName,\n      dbName: collection.dbName,\n      namespace: collection.namespace,\n    };\n    const spanContext: SpanContext = {\n      op: 'db',\n      description: operation,\n      data,\n    };\n\n    // If the operation takes no arguments besides `options` and `callback`, or if argument\n    // collection is disabled for this operation, just return early.\n    const signature = OPERATION_SIGNATURES[operation];\n    const shouldDescribe = Array.isArray(this._describeOperations)\n      ? this._describeOperations.includes(operation)\n      : this._describeOperations;\n\n    if (!signature || !shouldDescribe) {\n      return spanContext;\n    }\n\n    try {\n      // Special case for `mapReduce`, as the only one accepting functions as arguments.\n      if (operation === 'mapReduce') {\n        const [map, reduce] = args as { name?: string }[];\n        data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';\n        data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';\n      } else {\n        for (let i = 0; i < signature.length; i++) {\n          data[signature[i]] = JSON.stringify(args[i]);\n        }\n      }\n    } catch (_oO) {\n      // no-empty\n    }\n\n    return spanContext;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}