{"ast":null,"code":"import { __assign, __read, __spread, __values } from \"tslib\";\n/* eslint-disable max-lines */\nimport { Scope } from '@sentry/hub';\nimport { checkOrSetAlreadyCaught, dateTimestampInSeconds, isPlainObject, isPrimitive, isThenable, logger, makeDsn, normalize, rejectedSyncPromise, resolvedSyncPromise, SentryError, SyncPromise, truncate, uuid4 } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { setupIntegrations } from './integration';\nvar ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nvar BaseClient = /** @class */function () {\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  function BaseClient(backendClass, options) {\n    /** Array of used integrations. */\n    this._integrations = {};\n    /** Number of calls being processed */\n    this._numProcessing = 0;\n    this._backend = new backendClass(options);\n    this._options = options;\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    }\n  }\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  BaseClient.prototype.captureException = function (exception, hint, scope) {\n    var _this = this;\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n    var eventId = hint && hint.event_id;\n    this._process(this._getBackend().eventFromException(exception, hint).then(function (event) {\n      return _this._captureEvent(event, hint, scope);\n    }).then(function (result) {\n      eventId = result;\n    }));\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.captureMessage = function (message, level, hint, scope) {\n    var _this = this;\n    var eventId = hint && hint.event_id;\n    var promisedEvent = isPrimitive(message) ? this._getBackend().eventFromMessage(String(message), level, hint) : this._getBackend().eventFromException(message, hint);\n    this._process(promisedEvent.then(function (event) {\n      return _this._captureEvent(event, hint, scope);\n    }).then(function (result) {\n      eventId = result;\n    }));\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.captureEvent = function (event, hint, scope) {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n    var eventId = hint && hint.event_id;\n    this._process(this._captureEvent(event, hint, scope).then(function (result) {\n      eventId = result;\n    }));\n    return eventId;\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.captureSession = function (session) {\n    if (!this._isEnabled()) {\n      IS_DEBUG_BUILD && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n    if (!(typeof session.release === 'string')) {\n      IS_DEBUG_BUILD && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this._sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      session.update({\n        init: false\n      });\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.getDsn = function () {\n    return this._dsn;\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.getOptions = function () {\n    return this._options;\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.getTransport = function () {\n    return this._getBackend().getTransport();\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.flush = function (timeout) {\n    var _this = this;\n    return this._isClientDoneProcessing(timeout).then(function (clientFinished) {\n      return _this.getTransport().close(timeout).then(function (transportFlushed) {\n        return clientFinished && transportFlushed;\n      });\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.close = function (timeout) {\n    var _this = this;\n    return this.flush(timeout).then(function (result) {\n      _this.getOptions().enabled = false;\n      return result;\n    });\n  };\n  /**\n   * Sets up the integrations\n   */\n  BaseClient.prototype.setupIntegrations = function () {\n    if (this._isEnabled() && !this._integrations.initialized) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseClient.prototype.getIntegration = function (integration) {\n    try {\n      return this._integrations[integration.id] || null;\n    } catch (_oO) {\n      IS_DEBUG_BUILD && logger.warn(\"Cannot retrieve integration \" + integration.id + \" from the current Client\");\n      return null;\n    }\n  };\n  /** Updates existing session based on the provided event */\n  BaseClient.prototype._updateSessionFromEvent = function (session, event) {\n    var e_1, _a;\n    var crashed = false;\n    var errored = false;\n    var exceptions = event.exception && event.exception.values;\n    if (exceptions) {\n      errored = true;\n      try {\n        for (var exceptions_1 = __values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {\n          var ex = exceptions_1_1.value;\n          var mechanism = ex.mechanism;\n          if (mechanism && mechanism.handled === false) {\n            crashed = true;\n            break;\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return)) _a.call(exceptions_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n    }\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    var sessionNonTerminal = session.status === 'ok';\n    var shouldUpdateAndSend = sessionNonTerminal && session.errors === 0 || sessionNonTerminal && crashed;\n    if (shouldUpdateAndSend) {\n      session.update(__assign(__assign({}, crashed && {\n        status: 'crashed'\n      }), {\n        errors: session.errors || Number(errored || crashed)\n      }));\n      this.captureSession(session);\n    }\n  };\n  /** Deliver captured session to Sentry */\n  BaseClient.prototype._sendSession = function (session) {\n    this._getBackend().sendSession(session);\n  };\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  BaseClient.prototype._isClientDoneProcessing = function (timeout) {\n    var _this = this;\n    return new SyncPromise(function (resolve) {\n      var ticked = 0;\n      var tick = 1;\n      var interval = setInterval(function () {\n        if (_this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  };\n  /** Returns the current backend. */\n  BaseClient.prototype._getBackend = function () {\n    return this._backend;\n  };\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  BaseClient.prototype._isEnabled = function () {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  };\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  BaseClient.prototype._prepareEvent = function (event, scope, hint) {\n    var _this = this;\n    var _a = this.getOptions(),\n      _b = _a.normalizeDepth,\n      normalizeDepth = _b === void 0 ? 3 : _b,\n      _c = _a.normalizeMaxBreadth,\n      normalizeMaxBreadth = _c === void 0 ? 1000 : _c;\n    var prepared = __assign(__assign({}, event), {\n      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),\n      timestamp: event.timestamp || dateTimestampInSeconds()\n    });\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    var finalScope = scope;\n    if (hint && hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n    // We prepare the result here with a resolved Event.\n    var result = resolvedSyncPromise(prepared);\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n    return result.then(function (evt) {\n      if (evt) {\n        // TODO this is more of the hack trying to solve https://github.com/getsentry/sentry-javascript/issues/2809\n        // it is only attached as extra data to the event if the event somehow skips being normalized\n        evt.sdkProcessingMetadata = __assign(__assign({}, evt.sdkProcessingMetadata), {\n          normalizeDepth: normalize(normalizeDepth) + \" (\" + typeof normalizeDepth + \")\"\n        });\n      }\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return _this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  };\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n  BaseClient.prototype._normalizeEvent = function (event, depth, maxBreadth) {\n    if (!event) {\n      return null;\n    }\n    var normalized = __assign(__assign(__assign(__assign(__assign({}, event), event.breadcrumbs && {\n      breadcrumbs: event.breadcrumbs.map(function (b) {\n        return __assign(__assign({}, b), b.data && {\n          data: normalize(b.data, depth, maxBreadth)\n        });\n      })\n    }), event.user && {\n      user: normalize(event.user, depth, maxBreadth)\n    }), event.contexts && {\n      contexts: normalize(event.contexts, depth, maxBreadth)\n    }), event.extra && {\n      extra: normalize(event.extra, depth, maxBreadth)\n    });\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      normalized.contexts.trace = event.contexts.trace;\n    }\n    normalized.sdkProcessingMetadata = __assign(__assign({}, normalized.sdkProcessingMetadata), {\n      baseClientNormalized: true\n    });\n    return normalized;\n  };\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n  BaseClient.prototype._applyClientOptions = function (event) {\n    var options = this.getOptions();\n    var environment = options.environment,\n      release = options.release,\n      dist = options.dist,\n      _a = options.maxValueLength,\n      maxValueLength = _a === void 0 ? 250 : _a;\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n    var exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n    var request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  };\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param event The event that will be filled with all integrations.\n   */\n  BaseClient.prototype._applyIntegrationsMetadata = function (event) {\n    var integrationsArray = Object.keys(this._integrations);\n    if (integrationsArray.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = __spread(event.sdk.integrations || [], integrationsArray);\n    }\n  };\n  /**\n   * Tells the backend to send this event\n   * @param event The Sentry event to send\n   */\n  BaseClient.prototype._sendEvent = function (event) {\n    this._getBackend().sendEvent(event);\n  };\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  BaseClient.prototype._captureEvent = function (event, hint, scope) {\n    return this._processEvent(event, hint, scope).then(function (finalEvent) {\n      return finalEvent.event_id;\n    }, function (reason) {\n      IS_DEBUG_BUILD && logger.error(reason);\n      return undefined;\n    });\n  };\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  BaseClient.prototype._processEvent = function (event, hint, scope) {\n    var _this = this;\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    var _a = this.getOptions(),\n      beforeSend = _a.beforeSend,\n      sampleRate = _a.sampleRate;\n    var transport = this.getTransport();\n    function recordLostEvent(outcome, category) {\n      if (transport.recordLostEvent) {\n        transport.recordLostEvent(outcome, category);\n      }\n    }\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.'));\n    }\n    var isTransaction = event.type === 'transaction';\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      recordLostEvent('sample_rate', 'event');\n      return rejectedSyncPromise(new SentryError(\"Discarding event because it's not included in the random sample (sampling rate = \" + sampleRate + \")\"));\n    }\n    return this._prepareEvent(event, scope, hint).then(function (prepared) {\n      if (prepared === null) {\n        recordLostEvent('event_processor', event.type || 'event');\n        throw new SentryError('An event processor returned null, will not send event.');\n      }\n      var isInternalException = hint && hint.data && hint.data.__sentry__ === true;\n      if (isInternalException || isTransaction || !beforeSend) {\n        return prepared;\n      }\n      var beforeSendResult = beforeSend(prepared, hint);\n      return _ensureBeforeSendRv(beforeSendResult);\n    }).then(function (processedEvent) {\n      if (processedEvent === null) {\n        recordLostEvent('before_send', event.type || 'event');\n        throw new SentryError('`beforeSend` returned `null`, will not send event.');\n      }\n      var session = scope && scope.getSession && scope.getSession();\n      if (!isTransaction && session) {\n        _this._updateSessionFromEvent(session, processedEvent);\n      }\n      _this._sendEvent(processedEvent);\n      return processedEvent;\n    }).then(null, function (reason) {\n      if (reason instanceof SentryError) {\n        throw reason;\n      }\n      _this.captureException(reason, {\n        data: {\n          __sentry__: true\n        },\n        originalException: reason\n      });\n      throw new SentryError(\"Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: \" + reason);\n    });\n  };\n  /**\n   * Occupies the client with processing and event\n   */\n  BaseClient.prototype._process = function (promise) {\n    var _this = this;\n    this._numProcessing += 1;\n    void promise.then(function (value) {\n      _this._numProcessing -= 1;\n      return value;\n    }, function (reason) {\n      _this._numProcessing -= 1;\n      return reason;\n    });\n  };\n  return BaseClient;\n}();\nexport { BaseClient };\n/**\n * Verifies that return value of configured `beforeSend` is of expected type.\n */\nfunction _ensureBeforeSendRv(rv) {\n  var nullErr = '`beforeSend` method has to return `null` or a valid event.';\n  if (isThenable(rv)) {\n    return rv.then(function (event) {\n      if (!(isPlainObject(event) || event === null)) {\n        throw new SentryError(nullErr);\n      }\n      return event;\n    }, function (e) {\n      throw new SentryError(\"beforeSend rejected with \" + e);\n    });\n  } else if (!(isPlainObject(rv) || rv === null)) {\n    throw new SentryError(nullErr);\n  }\n  return rv;\n}","map":{"version":3,"names":["Scope","checkOrSetAlreadyCaught","dateTimestampInSeconds","isPlainObject","isPrimitive","isThenable","logger","makeDsn","normalize","rejectedSyncPromise","resolvedSyncPromise","SentryError","SyncPromise","truncate","uuid4","IS_DEBUG_BUILD","setupIntegrations","ALREADY_SEEN_ERROR","BaseClient","backendClass","options","_integrations","_numProcessing","_backend","_options","dsn","_dsn","prototype","captureException","exception","hint","scope","_this","log","eventId","event_id","_process","_getBackend","eventFromException","then","event","_captureEvent","result","captureMessage","message","level","promisedEvent","eventFromMessage","String","captureEvent","originalException","captureSession","session","_isEnabled","warn","release","_sendSession","update","init","getDsn","getOptions","getTransport","flush","timeout","_isClientDoneProcessing","clientFinished","close","transportFlushed","enabled","initialized","getIntegration","integration","id","_oO","_updateSessionFromEvent","crashed","errored","exceptions","values","exceptions_1","__values","exceptions_1_1","next","done","ex","value","mechanism","handled","sessionNonTerminal","status","shouldUpdateAndSend","errors","__assign","Number","sendSession","resolve","ticked","tick","interval","setInterval","clearInterval","undefined","_prepareEvent","_a","_b","normalizeDepth","_c","normalizeMaxBreadth","prepared","timestamp","_applyClientOptions","_applyIntegrationsMetadata","finalScope","captureContext","clone","applyToEvent","evt","sdkProcessingMetadata","_normalizeEvent","depth","maxBreadth","normalized","breadcrumbs","map","b","data","user","contexts","extra","trace","baseClientNormalized","environment","dist","maxValueLength","request","url","integrationsArray","Object","keys","length","sdk","integrations","__spread","_sendEvent","sendEvent","_processEvent","finalEvent","reason","error","beforeSend","sampleRate","transport","recordLostEvent","outcome","category","isTransaction","type","Math","random","isInternalException","__sentry__","beforeSendResult","_ensureBeforeSendRv","processedEvent","getSession","promise","rv","nullErr","e"],"sources":["../../src/baseclient.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport { Scope, Session } from '@sentry/hub';\nimport {\n  Client,\n  DsnComponents,\n  Event,\n  EventHint,\n  Integration,\n  IntegrationClass,\n  Options,\n  Severity,\n  Transport,\n} from '@sentry/types';\nimport {\n  checkOrSetAlreadyCaught,\n  dateTimestampInSeconds,\n  isPlainObject,\n  isPrimitive,\n  isThenable,\n  logger,\n  makeDsn,\n  normalize,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  SentryError,\n  SyncPromise,\n  truncate,\n  uuid4,\n} from '@sentry/utils';\n\nimport { Backend, BackendClass } from './basebackend';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { IntegrationIndex, setupIntegrations } from './integration';\n\nconst ALREADY_SEEN_ERROR = \"Not capturing exception because it's already been captured.\";\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * If a Dsn is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid Dsn, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient._prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options> implements Client<O> {\n  /**\n   * The backend used to physically interact in the environment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  protected readonly _backend: B;\n\n  /** Options passed to the SDK. */\n  protected readonly _options: O;\n\n  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */\n  protected readonly _dsn?: DsnComponents;\n\n  /** Array of used integrations. */\n  protected _integrations: IntegrationIndex = {};\n\n  /** Number of calls being processed */\n  protected _numProcessing: number = 0;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this._backend = new backendClass(options);\n    this._options = options;\n\n    if (options.dsn) {\n      this._dsn = makeDsn(options.dsn);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public captureException(exception: any, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (checkOrSetAlreadyCaught(exception)) {\n      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._getBackend()\n        .eventFromException(exception, hint)\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureMessage(message: string, level?: Severity, hint?: EventHint, scope?: Scope): string | undefined {\n    let eventId: string | undefined = hint && hint.event_id;\n\n    const promisedEvent = isPrimitive(message)\n      ? this._getBackend().eventFromMessage(String(message), level, hint)\n      : this._getBackend().eventFromException(message, hint);\n\n    this._process(\n      promisedEvent\n        .then(event => this._captureEvent(event, hint, scope))\n        .then(result => {\n          eventId = result;\n        }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureEvent(event: Event, hint?: EventHint, scope?: Scope): string | undefined {\n    // ensure we haven't captured this very object before\n    if (hint && hint.originalException && checkOrSetAlreadyCaught(hint.originalException)) {\n      IS_DEBUG_BUILD && logger.log(ALREADY_SEEN_ERROR);\n      return;\n    }\n\n    let eventId: string | undefined = hint && hint.event_id;\n\n    this._process(\n      this._captureEvent(event, hint, scope).then(result => {\n        eventId = result;\n      }),\n    );\n\n    return eventId;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public captureSession(session: Session): void {\n    if (!this._isEnabled()) {\n      IS_DEBUG_BUILD && logger.warn('SDK not enabled, will not capture session.');\n      return;\n    }\n\n    if (!(typeof session.release === 'string')) {\n      IS_DEBUG_BUILD && logger.warn('Discarded session because of missing or non-string release');\n    } else {\n      this._sendSession(session);\n      // After sending, we set init false to indicate it's not the first occurrence\n      session.update({ init: false });\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDsn(): DsnComponents | undefined {\n    return this._dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this._options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getTransport(): Transport {\n    return this._getBackend().getTransport();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public flush(timeout?: number): PromiseLike<boolean> {\n    return this._isClientDoneProcessing(timeout).then(clientFinished => {\n      return this.getTransport()\n        .close(timeout)\n        .then(transportFlushed => clientFinished && transportFlushed);\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this.flush(timeout).then(result => {\n      this.getOptions().enabled = false;\n      return result;\n    });\n  }\n\n  /**\n   * Sets up the integrations\n   */\n  public setupIntegrations(): void {\n    if (this._isEnabled() && !this._integrations.initialized) {\n      this._integrations = setupIntegrations(this._options);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getIntegration<T extends Integration>(integration: IntegrationClass<T>): T | null {\n    try {\n      return (this._integrations[integration.id] as T) || null;\n    } catch (_oO) {\n      IS_DEBUG_BUILD && logger.warn(`Cannot retrieve integration ${integration.id} from the current Client`);\n      return null;\n    }\n  }\n\n  /** Updates existing session based on the provided event */\n  protected _updateSessionFromEvent(session: Session, event: Event): void {\n    let crashed = false;\n    let errored = false;\n    const exceptions = event.exception && event.exception.values;\n\n    if (exceptions) {\n      errored = true;\n\n      for (const ex of exceptions) {\n        const mechanism = ex.mechanism;\n        if (mechanism && mechanism.handled === false) {\n          crashed = true;\n          break;\n        }\n      }\n    }\n\n    // A session is updated and that session update is sent in only one of the two following scenarios:\n    // 1. Session with non terminal status and 0 errors + an error occurred -> Will set error count to 1 and send update\n    // 2. Session with non terminal status and 1 error + a crash occurred -> Will set status crashed and send update\n    const sessionNonTerminal = session.status === 'ok';\n    const shouldUpdateAndSend = (sessionNonTerminal && session.errors === 0) || (sessionNonTerminal && crashed);\n\n    if (shouldUpdateAndSend) {\n      session.update({\n        ...(crashed && { status: 'crashed' }),\n        errors: session.errors || Number(errored || crashed),\n      });\n      this.captureSession(session);\n    }\n  }\n\n  /** Deliver captured session to Sentry */\n  protected _sendSession(session: Session): void {\n    this._getBackend().sendSession(session);\n  }\n\n  /**\n   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying\n   * \"no\" (resolving to `false`) in order to give the client a chance to potentially finish first.\n   *\n   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not\n   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to\n   * `true`.\n   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and\n   * `false` otherwise\n   */\n  protected _isClientDoneProcessing(timeout?: number): PromiseLike<boolean> {\n    return new SyncPromise(resolve => {\n      let ticked: number = 0;\n      const tick: number = 1;\n\n      const interval = setInterval(() => {\n        if (this._numProcessing == 0) {\n          clearInterval(interval);\n          resolve(true);\n        } else {\n          ticked += tick;\n          if (timeout && ticked >= timeout) {\n            clearInterval(interval);\n            resolve(false);\n          }\n        }\n      }, tick);\n    });\n  }\n\n  /** Returns the current backend. */\n  protected _getBackend(): B {\n    return this._backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid Dsn is present. */\n  protected _isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this._dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`,\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected _prepareEvent(event: Event, scope?: Scope, hint?: EventHint): PromiseLike<Event | null> {\n    const { normalizeDepth = 3, normalizeMaxBreadth = 1_000 } = this.getOptions();\n    const prepared: Event = {\n      ...event,\n      event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()),\n      timestamp: event.timestamp || dateTimestampInSeconds(),\n    };\n\n    this._applyClientOptions(prepared);\n    this._applyIntegrationsMetadata(prepared);\n\n    // If we have scope given to us, use it as the base for further modifications.\n    // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.\n    let finalScope = scope;\n    if (hint && hint.captureContext) {\n      finalScope = Scope.clone(finalScope).update(hint.captureContext);\n    }\n\n    // We prepare the result here with a resolved Event.\n    let result = resolvedSyncPromise<Event | null>(prepared);\n\n    // This should be the last thing called, since we want that\n    // {@link Hub.addEventProcessor} gets the finished prepared event.\n    if (finalScope) {\n      // In case we have a hub we reassign it.\n      result = finalScope.applyToEvent(prepared, hint);\n    }\n\n    return result.then(evt => {\n      if (evt) {\n        // TODO this is more of the hack trying to solve https://github.com/getsentry/sentry-javascript/issues/2809\n        // it is only attached as extra data to the event if the event somehow skips being normalized\n        evt.sdkProcessingMetadata = {\n          ...evt.sdkProcessingMetadata,\n          normalizeDepth: `${normalize(normalizeDepth)} (${typeof normalizeDepth})`,\n        };\n      }\n      if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {\n        return this._normalizeEvent(evt, normalizeDepth, normalizeMaxBreadth);\n      }\n      return evt;\n    });\n  }\n\n  /**\n   * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.\n   * Normalized keys:\n   * - `breadcrumbs.data`\n   * - `user`\n   * - `contexts`\n   * - `extra`\n   * @param event Event\n   * @returns Normalized event\n   */\n  protected _normalizeEvent(event: Event | null, depth: number, maxBreadth: number): Event | null {\n    if (!event) {\n      return null;\n    }\n\n    const normalized = {\n      ...event,\n      ...(event.breadcrumbs && {\n        breadcrumbs: event.breadcrumbs.map(b => ({\n          ...b,\n          ...(b.data && {\n            data: normalize(b.data, depth, maxBreadth),\n          }),\n        })),\n      }),\n      ...(event.user && {\n        user: normalize(event.user, depth, maxBreadth),\n      }),\n      ...(event.contexts && {\n        contexts: normalize(event.contexts, depth, maxBreadth),\n      }),\n      ...(event.extra && {\n        extra: normalize(event.extra, depth, maxBreadth),\n      }),\n    };\n    // event.contexts.trace stores information about a Transaction. Similarly,\n    // event.spans[] stores information about child Spans. Given that a\n    // Transaction is conceptually a Span, normalization should apply to both\n    // Transactions and Spans consistently.\n    // For now the decision is to skip normalization of Transactions and Spans,\n    // so this block overwrites the normalized event to add back the original\n    // Transaction information prior to normalization.\n    if (event.contexts && event.contexts.trace) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      normalized.contexts.trace = event.contexts.trace;\n    }\n\n    normalized.sdkProcessingMetadata = { ...normalized.sdkProcessingMetadata, baseClientNormalized: true };\n\n    return normalized;\n  }\n\n  /**\n   *  Enhances event using the client configuration.\n   *  It takes care of all \"static\" values like environment, release and `dist`,\n   *  as well as truncating overly long values.\n   * @param event event instance to be enhanced\n   */\n  protected _applyClientOptions(event: Event): void {\n    const options = this.getOptions();\n    const { environment, release, dist, maxValueLength = 250 } = options;\n\n    if (!('environment' in event)) {\n      event.environment = 'environment' in options ? environment : 'production';\n    }\n\n    if (event.release === undefined && release !== undefined) {\n      event.release = release;\n    }\n\n    if (event.dist === undefined && dist !== undefined) {\n      event.dist = dist;\n    }\n\n    if (event.message) {\n      event.message = truncate(event.message, maxValueLength);\n    }\n\n    const exception = event.exception && event.exception.values && event.exception.values[0];\n    if (exception && exception.value) {\n      exception.value = truncate(exception.value, maxValueLength);\n    }\n\n    const request = event.request;\n    if (request && request.url) {\n      request.url = truncate(request.url, maxValueLength);\n    }\n  }\n\n  /**\n   * This function adds all used integrations to the SDK info in the event.\n   * @param event The event that will be filled with all integrations.\n   */\n  protected _applyIntegrationsMetadata(event: Event): void {\n    const integrationsArray = Object.keys(this._integrations);\n    if (integrationsArray.length > 0) {\n      event.sdk = event.sdk || {};\n      event.sdk.integrations = [...(event.sdk.integrations || []), ...integrationsArray];\n    }\n  }\n\n  /**\n   * Tells the backend to send this event\n   * @param event The Sentry event to send\n   */\n  protected _sendEvent(event: Event): void {\n    this._getBackend().sendEvent(event);\n  }\n\n  /**\n   * Processes the event and logs an error in case of rejection\n   * @param event\n   * @param hint\n   * @param scope\n   */\n  protected _captureEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<string | undefined> {\n    return this._processEvent(event, hint, scope).then(\n      finalEvent => {\n        return finalEvent.event_id;\n      },\n      reason => {\n        IS_DEBUG_BUILD && logger.error(reason);\n        return undefined;\n      },\n    );\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   *\n   * @param event The event to send to Sentry.\n   * @param hint May contain additional information about the original exception.\n   * @param scope A scope containing event metadata.\n   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.\n   */\n  protected _processEvent(event: Event, hint?: EventHint, scope?: Scope): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    const { beforeSend, sampleRate } = this.getOptions();\n    const transport = this.getTransport();\n\n    type RecordLostEvent = NonNullable<Transport['recordLostEvent']>;\n    type RecordLostEventParams = Parameters<RecordLostEvent>;\n\n    function recordLostEvent(outcome: RecordLostEventParams[0], category: RecordLostEventParams[1]): void {\n      if (transport.recordLostEvent) {\n        transport.recordLostEvent(outcome, category);\n      }\n    }\n\n    if (!this._isEnabled()) {\n      return rejectedSyncPromise(new SentryError('SDK not enabled, will not capture event.'));\n    }\n\n    const isTransaction = event.type === 'transaction';\n    // 1.0 === 100% events are sent\n    // 0.0 === 0% events are sent\n    // Sampling for transaction happens somewhere else\n    if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {\n      recordLostEvent('sample_rate', 'event');\n      return rejectedSyncPromise(\n        new SentryError(\n          `Discarding event because it's not included in the random sample (sampling rate = ${sampleRate})`,\n        ),\n      );\n    }\n\n    return this._prepareEvent(event, scope, hint)\n      .then(prepared => {\n        if (prepared === null) {\n          recordLostEvent('event_processor', event.type || 'event');\n          throw new SentryError('An event processor returned null, will not send event.');\n        }\n\n        const isInternalException = hint && hint.data && (hint.data as { __sentry__: boolean }).__sentry__ === true;\n        if (isInternalException || isTransaction || !beforeSend) {\n          return prepared;\n        }\n\n        const beforeSendResult = beforeSend(prepared, hint);\n        return _ensureBeforeSendRv(beforeSendResult);\n      })\n      .then(processedEvent => {\n        if (processedEvent === null) {\n          recordLostEvent('before_send', event.type || 'event');\n          throw new SentryError('`beforeSend` returned `null`, will not send event.');\n        }\n\n        const session = scope && scope.getSession && scope.getSession();\n        if (!isTransaction && session) {\n          this._updateSessionFromEvent(session, processedEvent);\n        }\n\n        this._sendEvent(processedEvent);\n        return processedEvent;\n      })\n      .then(null, reason => {\n        if (reason instanceof SentryError) {\n          throw reason;\n        }\n\n        this.captureException(reason, {\n          data: {\n            __sentry__: true,\n          },\n          originalException: reason as Error,\n        });\n        throw new SentryError(\n          `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\\nReason: ${reason}`,\n        );\n      });\n  }\n\n  /**\n   * Occupies the client with processing and event\n   */\n  protected _process<T>(promise: PromiseLike<T>): void {\n    this._numProcessing += 1;\n    void promise.then(\n      value => {\n        this._numProcessing -= 1;\n        return value;\n      },\n      reason => {\n        this._numProcessing -= 1;\n        return reason;\n      },\n    );\n  }\n}\n\n/**\n * Verifies that return value of configured `beforeSend` is of expected type.\n */\nfunction _ensureBeforeSendRv(rv: PromiseLike<Event | null> | Event | null): PromiseLike<Event | null> | Event | null {\n  const nullErr = '`beforeSend` method has to return `null` or a valid event.';\n  if (isThenable(rv)) {\n    return rv.then(\n      event => {\n        if (!(isPlainObject(event) || event === null)) {\n          throw new SentryError(nullErr);\n        }\n        return event;\n      },\n      e => {\n        throw new SentryError(`beforeSend rejected with ${e}`);\n      },\n    );\n  } else if (!(isPlainObject(rv) || rv === null)) {\n    throw new SentryError(nullErr);\n  }\n  return rv;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}