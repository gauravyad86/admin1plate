{"ast":null,"code":"import { __read, __spread } from \"tslib\";\nimport { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { addNonEnumerableProperty, logger } from '@sentry/utils';\nimport { IS_DEBUG_BUILD } from './flags';\nexport var installedIntegrations = [];\n/**\n * @private\n */\nfunction filterDuplicates(integrations) {\n  return integrations.reduce(function (acc, integrations) {\n    if (acc.every(function (accIntegration) {\n      return integrations.name !== accIntegration.name;\n    })) {\n      acc.push(integrations);\n    }\n    return acc;\n  }, []);\n}\n/** Gets integration to install */\nexport function getIntegrationsToSetup(options) {\n  var defaultIntegrations = options.defaultIntegrations && __spread(options.defaultIntegrations) || [];\n  var userIntegrations = options.integrations;\n  var integrations = __spread(filterDuplicates(defaultIntegrations));\n  if (Array.isArray(userIntegrations)) {\n    // Filter out integrations that are also included in user options\n    integrations = __spread(integrations.filter(function (integrations) {\n      return userIntegrations.every(function (userIntegration) {\n        return userIntegration.name !== integrations.name;\n      });\n    }), filterDuplicates(userIntegrations));\n  } else if (typeof userIntegrations === 'function') {\n    integrations = userIntegrations(integrations);\n    integrations = Array.isArray(integrations) ? integrations : [integrations];\n  }\n  // Make sure that if present, `Debug` integration will always run last\n  var integrationsNames = integrations.map(function (i) {\n    return i.name;\n  });\n  var alwaysLastToRun = 'Debug';\n  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {\n    integrations.push.apply(integrations, __spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));\n  }\n  return integrations;\n}\n/** Setup given integration */\nexport function setupIntegration(integration) {\n  if (installedIntegrations.indexOf(integration.name) !== -1) {\n    return;\n  }\n  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n  installedIntegrations.push(integration.name);\n  IS_DEBUG_BUILD && logger.log(\"Integration installed: \" + integration.name);\n}\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations(options) {\n  var integrations = {};\n  getIntegrationsToSetup(options).forEach(function (integration) {\n    integrations[integration.name] = integration;\n    setupIntegration(integration);\n  });\n  // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`\n  // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be\n  // considered a member of the index the way the actual integrations are\n  addNonEnumerableProperty(integrations, 'initialized', true);\n  return integrations;\n}","map":{"version":3,"names":["addGlobalEventProcessor","getCurrentHub","addNonEnumerableProperty","logger","IS_DEBUG_BUILD","installedIntegrations","filterDuplicates","integrations","reduce","acc","every","accIntegration","name","push","getIntegrationsToSetup","options","defaultIntegrations","__spread","userIntegrations","Array","isArray","filter","userIntegration","integrationsNames","map","i","alwaysLastToRun","indexOf","apply","splice","setupIntegration","integration","setupOnce","log","setupIntegrations","forEach"],"sources":["../../src/integration.ts"],"sourcesContent":["import { addGlobalEventProcessor, getCurrentHub } from '@sentry/hub';\nimport { Integration, Options } from '@sentry/types';\nimport { addNonEnumerableProperty, logger } from '@sentry/utils';\n\nimport { IS_DEBUG_BUILD } from './flags';\n\nexport const installedIntegrations: string[] = [];\n\n/** Map of integrations assigned to a client */\nexport type IntegrationIndex = {\n  [key: string]: Integration;\n} & { initialized?: boolean };\n\n/**\n * @private\n */\nfunction filterDuplicates(integrations: Integration[]): Integration[] {\n  return integrations.reduce((acc, integrations) => {\n    if (acc.every(accIntegration => integrations.name !== accIntegration.name)) {\n      acc.push(integrations);\n    }\n    return acc;\n  }, [] as Integration[]);\n}\n\n/** Gets integration to install */\nexport function getIntegrationsToSetup(options: Options): Integration[] {\n  const defaultIntegrations = (options.defaultIntegrations && [...options.defaultIntegrations]) || [];\n  const userIntegrations = options.integrations;\n\n  let integrations: Integration[] = [...filterDuplicates(defaultIntegrations)];\n\n  if (Array.isArray(userIntegrations)) {\n    // Filter out integrations that are also included in user options\n    integrations = [\n      ...integrations.filter(integrations =>\n        userIntegrations.every(userIntegration => userIntegration.name !== integrations.name),\n      ),\n      // And filter out duplicated user options integrations\n      ...filterDuplicates(userIntegrations),\n    ];\n  } else if (typeof userIntegrations === 'function') {\n    integrations = userIntegrations(integrations);\n    integrations = Array.isArray(integrations) ? integrations : [integrations];\n  }\n\n  // Make sure that if present, `Debug` integration will always run last\n  const integrationsNames = integrations.map(i => i.name);\n  const alwaysLastToRun = 'Debug';\n  if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {\n    integrations.push(...integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1));\n  }\n\n  return integrations;\n}\n\n/** Setup given integration */\nexport function setupIntegration(integration: Integration): void {\n  if (installedIntegrations.indexOf(integration.name) !== -1) {\n    return;\n  }\n  integration.setupOnce(addGlobalEventProcessor, getCurrentHub);\n  installedIntegrations.push(integration.name);\n  IS_DEBUG_BUILD && logger.log(`Integration installed: ${integration.name}`);\n}\n\n/**\n * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default\n * integrations are added unless they were already provided before.\n * @param integrations array of integration instances\n * @param withDefault should enable default integrations\n */\nexport function setupIntegrations<O extends Options>(options: O): IntegrationIndex {\n  const integrations: IntegrationIndex = {};\n  getIntegrationsToSetup(options).forEach(integration => {\n    integrations[integration.name] = integration;\n    setupIntegration(integration);\n  });\n  // set the `initialized` flag so we don't run through the process again unecessarily; use `Object.defineProperty`\n  // because by default it creates a property which is nonenumerable, which we want since `initialized` shouldn't be\n  // considered a member of the index the way the actual integrations are\n  addNonEnumerableProperty(integrations, 'initialized', true);\n  return integrations;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}