{"ast":null,"code":"import { __extends, __values } from \"tslib\";\nimport { logger, timestampWithMs } from '@sentry/utils';\nimport { FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS } from './constants';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { SpanRecorder } from './span';\nimport { Transaction } from './transaction';\nexport var DEFAULT_IDLE_TIMEOUT = 1000;\nexport var HEARTBEAT_INTERVAL = 5000;\n/**\n * @inheritDoc\n */\nvar IdleTransactionSpanRecorder = /** @class */function (_super) {\n  __extends(IdleTransactionSpanRecorder, _super);\n  function IdleTransactionSpanRecorder(_pushActivity, _popActivity, transactionSpanId, maxlen) {\n    if (transactionSpanId === void 0) {\n      transactionSpanId = '';\n    }\n    var _this = _super.call(this, maxlen) || this;\n    _this._pushActivity = _pushActivity;\n    _this._popActivity = _popActivity;\n    _this.transactionSpanId = transactionSpanId;\n    return _this;\n  }\n  /**\n   * @inheritDoc\n   */\n  IdleTransactionSpanRecorder.prototype.add = function (span) {\n    var _this = this;\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = function (endTimestamp) {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        _this._popActivity(span.spanId);\n      };\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n    _super.prototype.add.call(this, span);\n  };\n  return IdleTransactionSpanRecorder;\n}(SpanRecorder);\nexport { IdleTransactionSpanRecorder };\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nvar IdleTransaction = /** @class */function (_super) {\n  __extends(IdleTransaction, _super);\n  function IdleTransaction(transactionContext, _idleHub,\n  /**\n   * The time to wait in ms until the idle transaction will be finished.\n   * @default 1000\n   */\n  _idleTimeout,\n  // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n  _onScope) {\n    if (_idleTimeout === void 0) {\n      _idleTimeout = DEFAULT_IDLE_TIMEOUT;\n    }\n    if (_onScope === void 0) {\n      _onScope = false;\n    }\n    var _this = _super.call(this, transactionContext, _idleHub) || this;\n    _this._idleHub = _idleHub;\n    _this._idleTimeout = _idleTimeout;\n    _this._onScope = _onScope;\n    // Activities store a list of active spans\n    _this.activities = {};\n    // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n    _this._heartbeatCounter = 0;\n    // We should not use heartbeat if we finished a transaction\n    _this._finished = false;\n    _this._beforeFinishCallbacks = [];\n    if (_idleHub && _onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      IS_DEBUG_BUILD && logger.log(\"Setting idle transaction on scope. Span ID: \" + _this.spanId);\n      _idleHub.configureScope(function (scope) {\n        return scope.setSpan(_this);\n      });\n    }\n    _this._initTimeout = setTimeout(function () {\n      if (!_this._finished) {\n        _this.finish();\n      }\n    }, _this._idleTimeout);\n    return _this;\n  }\n  /** {@inheritDoc} */\n  IdleTransaction.prototype.finish = function (endTimestamp) {\n    var e_1, _a;\n    var _this = this;\n    if (endTimestamp === void 0) {\n      endTimestamp = timestampWithMs();\n    }\n    this._finished = true;\n    this.activities = {};\n    if (this.spanRecorder) {\n      IS_DEBUG_BUILD && logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n      try {\n        for (var _b = __values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var callback = _c.value;\n          callback(this, endTimestamp);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      this.spanRecorder.spans = this.spanRecorder.spans.filter(function (span) {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === _this.spanId) {\n          return true;\n        }\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          IS_DEBUG_BUILD && logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n        var keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          IS_DEBUG_BUILD && logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));\n        }\n        return keepSpan;\n      });\n      IS_DEBUG_BUILD && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      IS_DEBUG_BUILD && logger.log('[Tracing] No active IdleTransaction');\n    }\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n    return _super.prototype.finish.call(this, endTimestamp);\n  };\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  IdleTransaction.prototype.registerBeforeFinishCallback = function (callback) {\n    this._beforeFinishCallbacks.push(callback);\n  };\n  /**\n   * @inheritDoc\n   */\n  IdleTransaction.prototype.initSpanRecorder = function (maxlen) {\n    var _this = this;\n    if (!this.spanRecorder) {\n      var pushActivity = function (id) {\n        if (_this._finished) {\n          return;\n        }\n        _this._pushActivity(id);\n      };\n      var popActivity = function (id) {\n        if (_this._finished) {\n          return;\n        }\n        _this._popActivity(id);\n      };\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n      // Start heartbeat so that transactions do not run forever.\n      IS_DEBUG_BUILD && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  };\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  IdleTransaction.prototype._pushActivity = function (spanId) {\n    if (this._initTimeout) {\n      clearTimeout(this._initTimeout);\n      this._initTimeout = undefined;\n    }\n    IS_DEBUG_BUILD && logger.log(\"[Tracing] pushActivity: \" + spanId);\n    this.activities[spanId] = true;\n    IS_DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  };\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  IdleTransaction.prototype._popActivity = function (spanId) {\n    var _this = this;\n    if (this.activities[spanId]) {\n      IS_DEBUG_BUILD && logger.log(\"[Tracing] popActivity \" + spanId);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      IS_DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n    if (Object.keys(this.activities).length === 0) {\n      var timeout = this._idleTimeout;\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      var end_1 = timestampWithMs() + timeout / 1000;\n      setTimeout(function () {\n        if (!_this._finished) {\n          _this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[1]);\n          _this.finish(end_1);\n        }\n      }, timeout);\n    }\n  };\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  IdleTransaction.prototype._beat = function () {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n    var heartbeatString = Object.keys(this.activities).join('');\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n    this._prevHeartbeatString = heartbeatString;\n    if (this._heartbeatCounter >= 3) {\n      IS_DEBUG_BUILD && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[0]);\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  };\n  /**\n   * Pings the heartbeat\n   */\n  IdleTransaction.prototype._pingHeartbeat = function () {\n    var _this = this;\n    IS_DEBUG_BUILD && logger.log(\"pinging Heartbeat -> current counter: \" + this._heartbeatCounter);\n    setTimeout(function () {\n      _this._beat();\n    }, HEARTBEAT_INTERVAL);\n  };\n  return IdleTransaction;\n}(Transaction);\nexport { IdleTransaction };\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub) {\n  if (hub) {\n    var scope = hub.getScope();\n    if (scope) {\n      var transaction = scope.getTransaction();\n      if (transaction) {\n        scope.setSpan(undefined);\n      }\n    }\n  }\n}","map":{"version":3,"names":["logger","timestampWithMs","FINISH_REASON_TAG","IDLE_TRANSACTION_FINISH_REASONS","IS_DEBUG_BUILD","SpanRecorder","Transaction","DEFAULT_IDLE_TIMEOUT","HEARTBEAT_INTERVAL","IdleTransactionSpanRecorder","_super","__extends","_pushActivity","_popActivity","transactionSpanId","maxlen","_this","call","prototype","add","span","spanId","finish","endTimestamp","undefined","IdleTransaction","transactionContext","_idleHub","_idleTimeout","_onScope","activities","_heartbeatCounter","_finished","_beforeFinishCallbacks","clearActiveTransaction","log","configureScope","scope","setSpan","_initTimeout","setTimeout","spanRecorder","Date","toISOString","op","_b","__values","_c","next","done","callback","value","spans","filter","setStatus","JSON","stringify","keepSpan","startTimestamp","registerBeforeFinishCallback","push","initSpanRecorder","pushActivity","id","popActivity","_pingHeartbeat","clearTimeout","Object","keys","length","timeout","end_1","setTag","_beat","heartbeatString","join","_prevHeartbeatString","hub","getScope","transaction","getTransaction"],"sources":["../../../src/idletransaction.ts"],"sourcesContent":["import { Hub } from '@sentry/hub';\nimport { TransactionContext } from '@sentry/types';\nimport { logger, timestampWithMs } from '@sentry/utils';\n\nimport { FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS } from './constants';\nimport { IS_DEBUG_BUILD } from './flags';\nimport { Span, SpanRecorder } from './span';\nimport { Transaction } from './transaction';\n\nexport const DEFAULT_IDLE_TIMEOUT = 1000;\nexport const HEARTBEAT_INTERVAL = 5000;\n\n/**\n * @inheritDoc\n */\nexport class IdleTransactionSpanRecorder extends SpanRecorder {\n  public constructor(\n    private readonly _pushActivity: (id: string) => void,\n    private readonly _popActivity: (id: string) => void,\n    public transactionSpanId: string = '',\n    maxlen?: number,\n  ) {\n    super(maxlen);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public add(span: Span): void {\n    // We should make sure we do not push and pop activities for\n    // the transaction that this span recorder belongs to.\n    if (span.spanId !== this.transactionSpanId) {\n      // We patch span.finish() to pop an activity after setting an endTimestamp.\n      span.finish = (endTimestamp?: number) => {\n        span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();\n        this._popActivity(span.spanId);\n      };\n\n      // We should only push new activities if the span does not have an end timestamp.\n      if (span.endTimestamp === undefined) {\n        this._pushActivity(span.spanId);\n      }\n    }\n\n    super.add(span);\n  }\n}\n\nexport type BeforeFinishCallback = (transactionSpan: IdleTransaction, endTimestamp: number) => void;\n\n/**\n * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.\n * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will\n * put itself on the scope on creation.\n */\nexport class IdleTransaction extends Transaction {\n  // Activities store a list of active spans\n  public activities: Record<string, boolean> = {};\n\n  // Track state of activities in previous heartbeat\n  private _prevHeartbeatString: string | undefined;\n\n  // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.\n  private _heartbeatCounter: number = 0;\n\n  // We should not use heartbeat if we finished a transaction\n  private _finished: boolean = false;\n\n  private readonly _beforeFinishCallbacks: BeforeFinishCallback[] = [];\n\n  /**\n   * If a transaction is created and no activities are added, we want to make sure that\n   * it times out properly. This is cleared and not used when activities are added.\n   */\n  private _initTimeout: ReturnType<typeof setTimeout> | undefined;\n\n  public constructor(\n    transactionContext: TransactionContext,\n    private readonly _idleHub?: Hub,\n    /**\n     * The time to wait in ms until the idle transaction will be finished.\n     * @default 1000\n     */\n    private readonly _idleTimeout: number = DEFAULT_IDLE_TIMEOUT,\n    // Whether or not the transaction should put itself on the scope when it starts and pop itself off when it ends\n    private readonly _onScope: boolean = false,\n  ) {\n    super(transactionContext, _idleHub);\n\n    if (_idleHub && _onScope) {\n      // There should only be one active transaction on the scope\n      clearActiveTransaction(_idleHub);\n\n      // We set the transaction here on the scope so error events pick up the trace\n      // context and attach it to the error.\n      IS_DEBUG_BUILD && logger.log(`Setting idle transaction on scope. Span ID: ${this.spanId}`);\n      _idleHub.configureScope(scope => scope.setSpan(this));\n    }\n\n    this._initTimeout = setTimeout(() => {\n      if (!this._finished) {\n        this.finish();\n      }\n    }, this._idleTimeout);\n  }\n\n  /** {@inheritDoc} */\n  public finish(endTimestamp: number = timestampWithMs()): string | undefined {\n    this._finished = true;\n    this.activities = {};\n\n    if (this.spanRecorder) {\n      IS_DEBUG_BUILD &&\n        logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);\n\n      for (const callback of this._beforeFinishCallbacks) {\n        callback(this, endTimestamp);\n      }\n\n      this.spanRecorder.spans = this.spanRecorder.spans.filter((span: Span) => {\n        // If we are dealing with the transaction itself, we just return it\n        if (span.spanId === this.spanId) {\n          return true;\n        }\n\n        // We cancel all pending spans with status \"cancelled\" to indicate the idle transaction was finished early\n        if (!span.endTimestamp) {\n          span.endTimestamp = endTimestamp;\n          span.setStatus('cancelled');\n          IS_DEBUG_BUILD &&\n            logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));\n        }\n\n        const keepSpan = span.startTimestamp < endTimestamp;\n        if (!keepSpan) {\n          IS_DEBUG_BUILD &&\n            logger.log(\n              '[Tracing] discarding Span since it happened after Transaction was finished',\n              JSON.stringify(span, undefined, 2),\n            );\n        }\n        return keepSpan;\n      });\n\n      IS_DEBUG_BUILD && logger.log('[Tracing] flushing IdleTransaction');\n    } else {\n      IS_DEBUG_BUILD && logger.log('[Tracing] No active IdleTransaction');\n    }\n\n    // if `this._onScope` is `true`, the transaction put itself on the scope when it started\n    if (this._onScope) {\n      clearActiveTransaction(this._idleHub);\n    }\n\n    return super.finish(endTimestamp);\n  }\n\n  /**\n   * Register a callback function that gets excecuted before the transaction finishes.\n   * Useful for cleanup or if you want to add any additional spans based on current context.\n   *\n   * This is exposed because users have no other way of running something before an idle transaction\n   * finishes.\n   */\n  public registerBeforeFinishCallback(callback: BeforeFinishCallback): void {\n    this._beforeFinishCallbacks.push(callback);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public initSpanRecorder(maxlen?: number): void {\n    if (!this.spanRecorder) {\n      const pushActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._pushActivity(id);\n      };\n      const popActivity = (id: string): void => {\n        if (this._finished) {\n          return;\n        }\n        this._popActivity(id);\n      };\n\n      this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);\n\n      // Start heartbeat so that transactions do not run forever.\n      IS_DEBUG_BUILD && logger.log('Starting heartbeat');\n      this._pingHeartbeat();\n    }\n    this.spanRecorder.add(this);\n  }\n\n  /**\n   * Start tracking a specific activity.\n   * @param spanId The span id that represents the activity\n   */\n  private _pushActivity(spanId: string): void {\n    if (this._initTimeout) {\n      clearTimeout(this._initTimeout);\n      this._initTimeout = undefined;\n    }\n    IS_DEBUG_BUILD && logger.log(`[Tracing] pushActivity: ${spanId}`);\n    this.activities[spanId] = true;\n    IS_DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n  }\n\n  /**\n   * Remove an activity from usage\n   * @param spanId The span id that represents the activity\n   */\n  private _popActivity(spanId: string): void {\n    if (this.activities[spanId]) {\n      IS_DEBUG_BUILD && logger.log(`[Tracing] popActivity ${spanId}`);\n      // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n      delete this.activities[spanId];\n      IS_DEBUG_BUILD && logger.log('[Tracing] new activities count', Object.keys(this.activities).length);\n    }\n\n    if (Object.keys(this.activities).length === 0) {\n      const timeout = this._idleTimeout;\n      // We need to add the timeout here to have the real endtimestamp of the transaction\n      // Remember timestampWithMs is in seconds, timeout is in ms\n      const end = timestampWithMs() + timeout / 1000;\n\n      setTimeout(() => {\n        if (!this._finished) {\n          this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[1]);\n          this.finish(end);\n        }\n      }, timeout);\n    }\n  }\n\n  /**\n   * Checks when entries of this.activities are not changing for 3 beats.\n   * If this occurs we finish the transaction.\n   */\n  private _beat(): void {\n    // We should not be running heartbeat if the idle transaction is finished.\n    if (this._finished) {\n      return;\n    }\n\n    const heartbeatString = Object.keys(this.activities).join('');\n\n    if (heartbeatString === this._prevHeartbeatString) {\n      this._heartbeatCounter += 1;\n    } else {\n      this._heartbeatCounter = 1;\n    }\n\n    this._prevHeartbeatString = heartbeatString;\n\n    if (this._heartbeatCounter >= 3) {\n      IS_DEBUG_BUILD && logger.log('[Tracing] Transaction finished because of no change for 3 heart beats');\n      this.setStatus('deadline_exceeded');\n      this.setTag(FINISH_REASON_TAG, IDLE_TRANSACTION_FINISH_REASONS[0]);\n      this.finish();\n    } else {\n      this._pingHeartbeat();\n    }\n  }\n\n  /**\n   * Pings the heartbeat\n   */\n  private _pingHeartbeat(): void {\n    IS_DEBUG_BUILD && logger.log(`pinging Heartbeat -> current counter: ${this._heartbeatCounter}`);\n    setTimeout(() => {\n      this._beat();\n    }, HEARTBEAT_INTERVAL);\n  }\n}\n\n/**\n * Reset transaction on scope to `undefined`\n */\nfunction clearActiveTransaction(hub?: Hub): void {\n  if (hub) {\n    const scope = hub.getScope();\n    if (scope) {\n      const transaction = scope.getTransaction();\n      if (transaction) {\n        scope.setSpan(undefined);\n      }\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}