{"ast":null,"code":"import { disabledUntil, eventStatusFromHttpCode, getEnvelopeType, isRateLimited, makePromiseBuffer, rejectedSyncPromise, resolvedSyncPromise, serializeEnvelope, updateRateLimits } from '@sentry/utils';\nexport var ERROR_TRANSPORT_CATEGORY = 'error';\nexport var TRANSACTION_TRANSPORT_CATEGORY = 'transaction';\nexport var ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';\nexport var SESSION_TRANSPORT_CATEGORY = 'session';\nexport var DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n/**\n * Creates a `NewTransport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(options, makeRequest, buffer) {\n  if (buffer === void 0) {\n    buffer = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE);\n  }\n  var rateLimits = {};\n  var flush = function (timeout) {\n    return buffer.drain(timeout);\n  };\n  function send(envelope) {\n    var envCategory = getEnvelopeType(envelope);\n    var category = envCategory === 'event' ? 'error' : envCategory;\n    var request = {\n      category: category,\n      body: serializeEnvelope(envelope)\n    };\n    // Don't add to buffer if transport is already rate-limited\n    if (isRateLimited(rateLimits, category)) {\n      return rejectedSyncPromise({\n        status: 'rate_limit',\n        reason: getRateLimitReason(rateLimits, category)\n      });\n    }\n    var requestTask = function () {\n      return makeRequest(request).then(function (_a) {\n        var body = _a.body,\n          headers = _a.headers,\n          reason = _a.reason,\n          statusCode = _a.statusCode;\n        var status = eventStatusFromHttpCode(statusCode);\n        if (headers) {\n          rateLimits = updateRateLimits(rateLimits, headers);\n        }\n        if (status === 'success') {\n          return resolvedSyncPromise({\n            status: status,\n            reason: reason\n          });\n        }\n        return rejectedSyncPromise({\n          status: status,\n          reason: reason || body || (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error')\n        });\n      });\n    };\n    return buffer.add(requestTask);\n  }\n  return {\n    send: send,\n    flush: flush\n  };\n}\nfunction getRateLimitReason(rateLimits, category) {\n  return \"Too many \" + category + \" requests, backing off until: \" + new Date(disabledUntil(rateLimits, category)).toISOString();\n}","map":{"version":3,"names":["disabledUntil","eventStatusFromHttpCode","getEnvelopeType","isRateLimited","makePromiseBuffer","rejectedSyncPromise","resolvedSyncPromise","serializeEnvelope","updateRateLimits","ERROR_TRANSPORT_CATEGORY","TRANSACTION_TRANSPORT_CATEGORY","ATTACHMENT_TRANSPORT_CATEGORY","SESSION_TRANSPORT_CATEGORY","DEFAULT_TRANSPORT_BUFFER_SIZE","createTransport","options","makeRequest","buffer","bufferSize","rateLimits","flush","timeout","drain","send","envelope","envCategory","category","request","body","status","reason","getRateLimitReason","requestTask","then","_a","headers","statusCode","add","Date","toISOString"],"sources":["../../../src/transports/base.ts"],"sourcesContent":["import { Envelope, EventStatus } from '@sentry/types';\nimport {\n  disabledUntil,\n  eventStatusFromHttpCode,\n  getEnvelopeType,\n  isRateLimited,\n  makePromiseBuffer,\n  PromiseBuffer,\n  RateLimits,\n  rejectedSyncPromise,\n  resolvedSyncPromise,\n  serializeEnvelope,\n  updateRateLimits,\n} from '@sentry/utils';\n\nexport const ERROR_TRANSPORT_CATEGORY = 'error';\n\nexport const TRANSACTION_TRANSPORT_CATEGORY = 'transaction';\n\nexport const ATTACHMENT_TRANSPORT_CATEGORY = 'attachment';\n\nexport const SESSION_TRANSPORT_CATEGORY = 'session';\n\ntype TransportCategory =\n  | typeof ERROR_TRANSPORT_CATEGORY\n  | typeof TRANSACTION_TRANSPORT_CATEGORY\n  | typeof ATTACHMENT_TRANSPORT_CATEGORY\n  | typeof SESSION_TRANSPORT_CATEGORY;\n\nexport type TransportRequest = {\n  body: string;\n  category: TransportCategory;\n};\n\nexport type TransportMakeRequestResponse = {\n  body?: string;\n  headers?: {\n    [key: string]: string | null;\n    'x-sentry-rate-limits': string | null;\n    'retry-after': string | null;\n  };\n  reason?: string;\n  statusCode: number;\n};\n\nexport type TransportResponse = {\n  status: EventStatus;\n  reason?: string;\n};\n\ninterface InternalBaseTransportOptions {\n  bufferSize?: number;\n}\n\nexport interface BaseTransportOptions extends InternalBaseTransportOptions {\n  // url to send the event\n  // transport does not care about dsn specific - client should take care of\n  // parsing and figuring that out\n  url: string;\n}\n\n// TODO: Move into Browser Transport\nexport interface BrowserTransportOptions extends BaseTransportOptions {\n  // options to pass into fetch request\n  fetchParams: Record<string, string>;\n  headers?: Record<string, string>;\n  sendClientReports?: boolean;\n}\n\nexport interface NewTransport {\n  send(request: Envelope): PromiseLike<TransportResponse>;\n  flush(timeout?: number): PromiseLike<boolean>;\n}\n\nexport type TransportRequestExecutor = (request: TransportRequest) => PromiseLike<TransportMakeRequestResponse>;\n\nexport const DEFAULT_TRANSPORT_BUFFER_SIZE = 30;\n\n/**\n * Creates a `NewTransport`\n *\n * @param options\n * @param makeRequest\n */\nexport function createTransport(\n  options: InternalBaseTransportOptions,\n  makeRequest: TransportRequestExecutor,\n  buffer: PromiseBuffer<TransportResponse> = makePromiseBuffer(options.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE),\n): NewTransport {\n  let rateLimits: RateLimits = {};\n\n  const flush = (timeout?: number): PromiseLike<boolean> => buffer.drain(timeout);\n\n  function send(envelope: Envelope): PromiseLike<TransportResponse> {\n    const envCategory = getEnvelopeType(envelope);\n    const category = envCategory === 'event' ? 'error' : (envCategory as TransportCategory);\n    const request: TransportRequest = {\n      category,\n      body: serializeEnvelope(envelope),\n    };\n\n    // Don't add to buffer if transport is already rate-limited\n    if (isRateLimited(rateLimits, category)) {\n      return rejectedSyncPromise({\n        status: 'rate_limit',\n        reason: getRateLimitReason(rateLimits, category),\n      });\n    }\n\n    const requestTask = (): PromiseLike<TransportResponse> =>\n      makeRequest(request).then(({ body, headers, reason, statusCode }): PromiseLike<TransportResponse> => {\n        const status = eventStatusFromHttpCode(statusCode);\n        if (headers) {\n          rateLimits = updateRateLimits(rateLimits, headers);\n        }\n        if (status === 'success') {\n          return resolvedSyncPromise({ status, reason });\n        }\n        return rejectedSyncPromise({\n          status,\n          reason:\n            reason ||\n            body ||\n            (status === 'rate_limit' ? getRateLimitReason(rateLimits, category) : 'Unknown transport error'),\n        });\n      });\n\n    return buffer.add(requestTask);\n  }\n\n  return {\n    send,\n    flush,\n  };\n}\n\nfunction getRateLimitReason(rateLimits: RateLimits, category: TransportCategory): string {\n  return `Too many ${category} requests, backing off until: ${new Date(\n    disabledUntil(rateLimits, category),\n  ).toISOString()}`;\n}\n"],"mappings":"AACA,SACEA,aAAa,EACbC,uBAAuB,EACvBC,eAAe,EACfC,aAAa,EACbC,iBAAiB,EAGjBC,mBAAmB,EACnBC,mBAAmB,EACnBC,iBAAiB,EACjBC,gBAAgB,QACX,eAAe;AAEtB,OAAO,IAAMC,wBAAwB,GAAG,OAAO;AAE/C,OAAO,IAAMC,8BAA8B,GAAG,aAAa;AAE3D,OAAO,IAAMC,6BAA6B,GAAG,YAAY;AAEzD,OAAO,IAAMC,0BAA0B,GAAG,SAAS;AAuDnD,OAAO,IAAMC,6BAA6B,GAAG,EAAE;AAE/C;;;;;;AAMA,OAAM,SAAUC,eAAeA,CAC7BC,OAAqC,EACrCC,WAAqC,EACrCC,MAAiH;EAAjH,IAAAA,MAAA;IAAAA,MAAA,GAA2Cb,iBAAiB,CAACW,OAAO,CAACG,UAAU,IAAIL,6BAA6B,CAAC;EAAA;EAEjH,IAAIM,UAAU,GAAe,EAAE;EAE/B,IAAMC,KAAK,GAAG,SAAAA,CAACC,OAAgB;IAA2B,OAAAJ,MAAM,CAACK,KAAK,CAACD,OAAO,CAAC;EAArB,CAAqB;EAE/E,SAASE,IAAIA,CAACC,QAAkB;IAC9B,IAAMC,WAAW,GAAGvB,eAAe,CAACsB,QAAQ,CAAC;IAC7C,IAAME,QAAQ,GAAGD,WAAW,KAAK,OAAO,GAAG,OAAO,GAAIA,WAAiC;IACvF,IAAME,OAAO,GAAqB;MAChCD,QAAQ,EAAAA,QAAA;MACRE,IAAI,EAAErB,iBAAiB,CAACiB,QAAQ;KACjC;IAED;IACA,IAAIrB,aAAa,CAACgB,UAAU,EAAEO,QAAQ,CAAC,EAAE;MACvC,OAAOrB,mBAAmB,CAAC;QACzBwB,MAAM,EAAE,YAAY;QACpBC,MAAM,EAAEC,kBAAkB,CAACZ,UAAU,EAAEO,QAAQ;OAChD,CAAC;;IAGJ,IAAMM,WAAW,GAAG,SAAAA,CAAA;MAClB,OAAAhB,WAAW,CAACW,OAAO,CAAC,CAACM,IAAI,CAAC,UAACC,EAAqC;YAAnCN,IAAA,GAAAM,EAAA,CAAAN,IAAI;UAAEO,OAAA,GAAAD,EAAA,CAAAC,OAAO;UAAEL,MAAA,GAAAI,EAAA,CAAAJ,MAAM;UAAEM,UAAA,GAAAF,EAAA,CAAAE,UAAU;QAC5D,IAAMP,MAAM,GAAG5B,uBAAuB,CAACmC,UAAU,CAAC;QAClD,IAAID,OAAO,EAAE;UACXhB,UAAU,GAAGX,gBAAgB,CAACW,UAAU,EAAEgB,OAAO,CAAC;;QAEpD,IAAIN,MAAM,KAAK,SAAS,EAAE;UACxB,OAAOvB,mBAAmB,CAAC;YAAEuB,MAAM,EAAAA,MAAA;YAAEC,MAAM,EAAAA;UAAA,CAAE,CAAC;;QAEhD,OAAOzB,mBAAmB,CAAC;UACzBwB,MAAM,EAAAA,MAAA;UACNC,MAAM,EACJA,MAAM,IACNF,IAAI,KACHC,MAAM,KAAK,YAAY,GAAGE,kBAAkB,CAACZ,UAAU,EAAEO,QAAQ,CAAC,GAAG,yBAAyB;SAClG,CAAC;MACJ,CAAC,CAAC;IAfF,CAeE;IAEJ,OAAOT,MAAM,CAACoB,GAAG,CAACL,WAAW,CAAC;EAChC;EAEA,OAAO;IACLT,IAAI,EAAAA,IAAA;IACJH,KAAK,EAAAA;GACN;AACH;AAEA,SAASW,kBAAkBA,CAACZ,UAAsB,EAAEO,QAA2B;EAC7E,OAAO,cAAYA,QAAQ,sCAAiC,IAAIY,IAAI,CAClEtC,aAAa,CAACmB,UAAU,EAAEO,QAAQ,CAAC,CACpC,CAACa,WAAW,EAAI;AACnB"},"metadata":{},"sourceType":"module"}