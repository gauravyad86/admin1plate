{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, createStackParser, extractExceptionKeysForMessage, isDOMError, isDOMException, isError, isErrorEvent, isEvent, isPlainObject, normalizeToSize, resolvedSyncPromise } from '@sentry/utils';\nimport { chromeStackParser, geckoStackParser, opera10StackParser, opera11StackParser, winjsStackParser } from './stack-parsers';\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\nexport function exceptionFromError(ex) {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  var frames = parseStackFrames(ex);\n  var exception = {\n    type: ex && ex.name,\n    value: extractMessage(ex)\n  };\n  if (frames.length) {\n    exception.stacktrace = {\n      frames: frames\n    };\n  }\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n  return exception;\n}\n/**\n * @hidden\n */\nexport function eventFromPlainObject(exception, syntheticException, isUnhandledRejection) {\n  var event = {\n    exception: {\n      values: [{\n        type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n        value: \"Non-Error \" + (isUnhandledRejection ? 'promise rejection' : 'exception') + \" captured with keys: \" + extractExceptionKeysForMessage(exception)\n      }]\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception)\n    }\n  };\n  if (syntheticException) {\n    var frames_1 = parseStackFrames(syntheticException);\n    if (frames_1.length) {\n      event.stacktrace = {\n        frames: frames_1\n      };\n    }\n  }\n  return event;\n}\n/**\n * @hidden\n */\nexport function eventFromError(ex) {\n  return {\n    exception: {\n      values: [exceptionFromError(ex)]\n    }\n  };\n}\n/** Parses stack frames from an error */\nexport function parseStackFrames(ex) {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  var stacktrace = ex.stacktrace || ex.stack || '';\n  var popSize = getPopSize(ex);\n  try {\n    return createStackParser(opera10StackParser, opera11StackParser, chromeStackParser, winjsStackParser, geckoStackParser)(stacktrace, popSize);\n  } catch (e) {\n    // no-empty\n  }\n  return [];\n}\n// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\nvar reactMinifiedRegexp = /Minified React error #\\d+;/i;\nfunction getPopSize(ex) {\n  if (ex) {\n    if (typeof ex.framesToPop === 'number') {\n      return ex.framesToPop;\n    }\n    if (reactMinifiedRegexp.test(ex.message)) {\n      return 1;\n    }\n  }\n  return 0;\n}\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\nfunction extractMessage(ex) {\n  var message = ex && ex.message;\n  if (!message) {\n    return 'No error message';\n  }\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n  return message;\n}\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\nexport function eventFromException(exception, hint, attachStacktrace) {\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);\n  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }\n  event.level = Severity.Error;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(message, level, hint, attachStacktrace) {\n  if (level === void 0) {\n    level = Severity.Info;\n  }\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromString(message, syntheticException, attachStacktrace);\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(exception, syntheticException, attachStacktrace, isUnhandledRejection) {\n  var event;\n  if (isErrorEvent(exception) && exception.error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    var errorEvent = exception;\n    return eventFromError(errorEvent.error);\n  }\n  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n  if (isDOMError(exception) || isDOMException(exception)) {\n    var domException = exception;\n    if ('stack' in exception) {\n      event = eventFromError(exception);\n    } else {\n      var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      var message = domException.message ? name_1 + \": \" + domException.message : name_1;\n      event = eventFromString(message, syntheticException, attachStacktrace);\n      addExceptionTypeValue(event, message);\n    }\n    if ('code' in domException) {\n      event.tags = __assign(__assign({}, event.tags), {\n        'DOMException.code': \"\" + domException.code\n      });\n    }\n    return event;\n  }\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    return eventFromError(exception);\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    var objectException = exception;\n    event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n    return event;\n  }\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(exception, syntheticException, attachStacktrace);\n  addExceptionTypeValue(event, \"\" + exception, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true\n  });\n  return event;\n}\n/**\n * @hidden\n */\nexport function eventFromString(input, syntheticException, attachStacktrace) {\n  var event = {\n    message: input\n  };\n  if (attachStacktrace && syntheticException) {\n    var frames_2 = parseStackFrames(syntheticException);\n    if (frames_2.length) {\n      event.stacktrace = {\n        frames: frames_2\n      };\n    }\n  }\n  return event;\n}","map":{"version":3,"names":["Severity","addExceptionMechanism","addExceptionTypeValue","createStackParser","extractExceptionKeysForMessage","isDOMError","isDOMException","isError","isErrorEvent","isEvent","isPlainObject","normalizeToSize","resolvedSyncPromise","chromeStackParser","geckoStackParser","opera10StackParser","opera11StackParser","winjsStackParser","exceptionFromError","ex","frames","parseStackFrames","exception","type","name","value","extractMessage","length","stacktrace","undefined","eventFromPlainObject","syntheticException","isUnhandledRejection","event","values","constructor","extra","__serialized__","frames_1","eventFromError","stack","popSize","getPopSize","e","reactMinifiedRegexp","framesToPop","test","message","error","eventFromException","hint","attachStacktrace","eventFromUnknownInput","level","Error","event_id","eventFromMessage","Info","eventFromString","errorEvent","domException","name_1","tags","__assign","code","objectException","synthetic","input","frames_2"],"sources":["../../../src/eventbuilder.ts"],"sourcesContent":["import { Event, EventHint, Exception, Severity, StackFrame } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  createStackParser,\n  extractExceptionKeysForMessage,\n  isDOMError,\n  isDOMException,\n  isError,\n  isErrorEvent,\n  isEvent,\n  isPlainObject,\n  normalizeToSize,\n  resolvedSyncPromise,\n} from '@sentry/utils';\n\nimport {\n  chromeStackParser,\n  geckoStackParser,\n  opera10StackParser,\n  opera11StackParser,\n  winjsStackParser,\n} from './stack-parsers';\n\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\nexport function exceptionFromError(ex: Error): Exception {\n  // Get the frames first since Opera can lose the stack if we touch anything else first\n  const frames = parseStackFrames(ex);\n\n  const exception: Exception = {\n    type: ex && ex.name,\n    value: extractMessage(ex),\n  };\n\n  if (frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\n/**\n * @hidden\n */\nexport function eventFromPlainObject(\n  exception: Record<string, unknown>,\n  syntheticException?: Error,\n  isUnhandledRejection?: boolean,\n): Event {\n  const event: Event = {\n    exception: {\n      values: [\n        {\n          type: isEvent(exception) ? exception.constructor.name : isUnhandledRejection ? 'UnhandledRejection' : 'Error',\n          value: `Non-Error ${\n            isUnhandledRejection ? 'promise rejection' : 'exception'\n          } captured with keys: ${extractExceptionKeysForMessage(exception)}`,\n        },\n      ],\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception),\n    },\n  };\n\n  if (syntheticException) {\n    const frames = parseStackFrames(syntheticException);\n    if (frames.length) {\n      event.stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromError(ex: Error): Event {\n  return {\n    exception: {\n      values: [exceptionFromError(ex)],\n    },\n  };\n}\n\n/** Parses stack frames from an error */\nexport function parseStackFrames(ex: Error & { framesToPop?: number; stacktrace?: string }): StackFrame[] {\n  // Access and store the stacktrace property before doing ANYTHING\n  // else to it because Opera is not very good at providing it\n  // reliably in other circumstances.\n  const stacktrace = ex.stacktrace || ex.stack || '';\n\n  const popSize = getPopSize(ex);\n\n  try {\n    return createStackParser(\n      opera10StackParser,\n      opera11StackParser,\n      chromeStackParser,\n      winjsStackParser,\n      geckoStackParser,\n    )(stacktrace, popSize);\n  } catch (e) {\n    // no-empty\n  }\n\n  return [];\n}\n\n// Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108\nconst reactMinifiedRegexp = /Minified React error #\\d+;/i;\n\nfunction getPopSize(ex: Error & { framesToPop?: number }): number {\n  if (ex) {\n    if (typeof ex.framesToPop === 'number') {\n      return ex.framesToPop;\n    }\n\n    if (reactMinifiedRegexp.test(ex.message)) {\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * There are cases where stacktrace.message is an Event object\n * https://github.com/getsentry/sentry-javascript/issues/1949\n * In this specific case we try to extract stacktrace.message.error.message\n */\nfunction extractMessage(ex: Error & { message: { error?: Error } }): string {\n  const message = ex && ex.message;\n  if (!message) {\n    return 'No error message';\n  }\n  if (message.error && typeof message.error.message === 'string') {\n    return message.error.message;\n  }\n  return message;\n}\n\n/**\n * Creates an {@link Event} from all inputs to `captureException` and non-primitive inputs to `captureMessage`.\n * @hidden\n */\nexport function eventFromException(\n  exception: unknown,\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromUnknownInput(exception, syntheticException, attachStacktrace);\n  addExceptionMechanism(event); // defaults to { type: 'generic', handled: true }\n  event.level = Severity.Error;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  message: string,\n  level: Severity = Severity.Info,\n  hint?: EventHint,\n  attachStacktrace?: boolean,\n): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromString(message, syntheticException, attachStacktrace);\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return resolvedSyncPromise(event);\n}\n\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(\n  exception: unknown,\n  syntheticException?: Error,\n  attachStacktrace?: boolean,\n  isUnhandledRejection?: boolean,\n): Event {\n  let event: Event;\n\n  if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    const errorEvent = exception as ErrorEvent;\n    return eventFromError(errorEvent.error as Error);\n  }\n\n  // If it is a `DOMError` (which is a legacy API, but still supported in some browsers) then we just extract the name\n  // and message, as it doesn't provide anything else. According to the spec, all `DOMExceptions` should also be\n  // `Error`s, but that's not the case in IE11, so in that case we treat it the same as we do a `DOMError`.\n  //\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n  // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n  // https://webidl.spec.whatwg.org/#es-DOMException-specialness\n  if (isDOMError(exception as DOMError) || isDOMException(exception as DOMException)) {\n    const domException = exception as DOMException;\n\n    if ('stack' in (exception as Error)) {\n      event = eventFromError(exception as Error);\n    } else {\n      const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n      const message = domException.message ? `${name}: ${domException.message}` : name;\n      event = eventFromString(message, syntheticException, attachStacktrace);\n      addExceptionTypeValue(event, message);\n    }\n    if ('code' in domException) {\n      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };\n    }\n\n    return event;\n  }\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    return eventFromError(exception);\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it's a plain object or an instance of `Event` (the built-in JS kind, not this SDK's `Event` type), serialize\n    // it manually. This will allow us to group events based on top-level keys which is much better than creating a new\n    // group on any key/value change.\n    const objectException = exception as Record<string, unknown>;\n    event = eventFromPlainObject(objectException, syntheticException, isUnhandledRejection);\n    addExceptionMechanism(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(exception as string, syntheticException, attachStacktrace);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromString(input: string, syntheticException?: Error, attachStacktrace?: boolean): Event {\n  const event: Event = {\n    message: input,\n  };\n\n  if (attachStacktrace && syntheticException) {\n    const frames = parseStackFrames(syntheticException);\n    if (frames.length) {\n      event.stacktrace = { frames };\n    }\n  }\n\n  return event;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}